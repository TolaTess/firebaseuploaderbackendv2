import { Meal } from '../types/meal';
import { CookingMethod, DietCategory, Program, PortionDetail } from '../types/collections';
import { Ingredient } from '../types/ingredient';

interface EnhancedMealData {
  description?: string;
  type?: 'protein' | 'grain' | 'vegetable' | 'fruit';
  cookingTime?: string;
  cookingMethod?: 'raw' | 'frying' | 'grilling' | 'boiling' | 'poaching' | 'braising' | 'other';  // Added 'other' to the list
  ingredients?: {
    [key: string]: string; // amount with unit (e.g., '1 cup', '200g')
  };
  instructions?: string[];
  nutritionalInfo?: {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  };
  categories?: string[];
  serveQty?: number;
  suggestions?: {
    improvements: string[];
    alternatives: string[];
    additions: string[];
  };
}

interface MealVariation {
  title: string;
  description?: string;
  type?: 'protein' | 'grain' | 'vegetable' | 'fruit';
  cookingTime?: string;
  cookingMethod?: 'raw' | 'frying' | 'grilling' | 'boiling' | 'poaching' | 'braising' | 'other';  // Added 'other' to the list
  ingredients?: {
    [key: string]: string; // amount with unit (e.g., '1 cup', '200g')
  };
  instructions?: string[];
  nutritionalInfo?: {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  };
  categories?: string[];
  serveQty?: number;
  suggestions?: {
    improvements: string[];
    alternatives: string[];
    additions: string[];
  };
}

interface EnhancedCookingMethod {
  description: string;
  howItWorks: string;
  equipment: string[];
  bestFor: string[];
  heatType: string;
}

interface EnhancedDietCategory {
  description: string;
  kidsFriendly: boolean;
}

interface EnhancedIngredientData {
  title?: string;
  type?: 'protein' | 'grain' | 'vegetable' | 'fruit' | 'sweetener' | 'condiment' | 'pastry' | 'dairy' | 'oil' | 'herb' | 'spice' | 'liquid';
  calories?: number;
  macros?: {
    protein: string;
    carbs: string;
    fat: string;
  };
  categories?: string[];
  features?: {
    fiber: string; // e.g., "10g"
    g_i: string; // glycemic index e.g., "40", "low", "medium", "high"
    season: 'spring' | 'summer' | 'autumn' | 'winter' | 'year-round' | 'fall/winter' | 'spring/summer';
    water: string; // e.g., "10%"
    rainbow: 'red' | 'orange' | 'yellow' | 'green' | 'blue' | 'purple' | 'white' | 'brown' | 'pink' | 'black';
  };
  techniques?: string[];
  storageOptions?: {
    countertop: string;
    fridge: string;
    freezer: string;
  };
  isAntiInflammatory?: boolean;
  alt?: string[];
  image?: string;
}

export class GeminiService {
  private apiKey: string;
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';

  constructor() {
    this.apiKey = process.env.VITE_GEMINI_API_KEY || '';
    if (!this.apiKey) {
      throw new Error('VITE_GEMINI_API_KEY environment variable is required');
    }
  }

  /**
   * Transforms a duplicate meal into a unique variation
   */
  async createMealVariation(originalMeal: Partial<Meal>, existingTitles: string[]): Promise<MealVariation> {
    const prompt = this.createVariationPrompt(originalMeal, existingTitles);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseVariationResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for variation:', error);
      throw error;
    }
  }

  /**
   * Enhances cooking method details using Gemini AI
   */
  async enhanceCookingMethod(cookingMethod: Partial<CookingMethod>): Promise<EnhancedCookingMethod> {
    const prompt = this.createCookingMethodPrompt(cookingMethod);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseCookingMethodResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for cooking method:', error);
      throw error;
    }
  }

  /**
   * Enhances diet category details using Gemini AI
   */
  async enhanceDietCategory(category: Partial<DietCategory>): Promise<EnhancedDietCategory> {
    const prompt = this.createDietCategoryPrompt(category);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseDietCategoryResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for diet category:', error);
      throw error;
    }
  }

  /**
   * Enhances meal data using Gemini AI
   */
  async enhanceMealDetails(meal: Partial<Meal>): Promise<EnhancedMealData> {
    const prompt = this.createEnhancementPrompt(meal);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseGeminiResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API:', error);
      throw error;
    }
  }

  /**
   * Enhances ingredient with complete details using Gemini AI
   */
  async enhanceIngredientDetails(ingredient: Partial<Ingredient>): Promise<EnhancedIngredientData> {
    // First check if the ingredient needs renaming
    if (ingredient.title && this.shouldRenameIngredient(ingredient.title)) {
      console.log(`Ingredient "${ingredient.title}" needs renaming`);
      const newTitle = await this.renameIngredient(ingredient);
      console.log(`Renamed "${ingredient.title}" to "${newTitle}"`);
      ingredient.title = newTitle;
    }

    const prompt = this.createIngredientEnhancementPrompt(ingredient);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseIngredientResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for ingredient enhancement (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback response for ingredient: ${ingredient.title}`);
          return {
            title: ingredient.title || 'Unknown Ingredient',
            type: 'vegetable', // Default to vegetable as a safe fallback
            calories: 0,
            macros: { protein: '0', carbs: '0', fat: '0' },
            categories: ['fallback'],
            features: {
              fiber: 'low',
              g_i: 'low',
              season: 'year-round',
              water: 'low',
              rainbow: 'white'
            },
            techniques: ['fallback'],
            storageOptions: {
              countertop: 'unknown',
              fridge: 'unknown',
              freezer: 'unknown'
            },
            isAntiInflammatory: false,
            alt: ['fallback'],
            image: ''
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to enhance ingredient after all retries');
  }

  /**
   * Creates an ingredient variation using Gemini AI
   */
  async createIngredientVariation(originalIngredient: Partial<Ingredient>, existingTitles: string[]): Promise<EnhancedIngredientData> {
    // First check if the ingredient needs renaming
    if (originalIngredient.title && this.shouldRenameIngredient(originalIngredient.title)) {
      console.log(`Ingredient "${originalIngredient.title}" needs renaming before creating variation`);
      const newTitle = await this.renameIngredient(originalIngredient);
      console.log(`Renamed "${originalIngredient.title}" to "${newTitle}" for variation creation`);
      originalIngredient.title = newTitle;
    }

    const prompt = this.createIngredientVariationPrompt(originalIngredient, existingTitles);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseIngredientResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for ingredient variation (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback variation for ingredient: ${originalIngredient.title}`);
          return {
            title: `${originalIngredient.title} Variation`,
            type: originalIngredient.type || 'vegetable',
            calories: originalIngredient.calories || 0,
            macros: originalIngredient.macros || { protein: '0', carbs: '0', fat: '0' },
            categories: originalIngredient.categories || ['fallback'],
            features: originalIngredient.features || {
              fiber: 'low',
              g_i: 'low',
              season: 'year-round',
              water: 'low',
              rainbow: 'white'
            },
            techniques: originalIngredient.techniques || ['fallback'],
            storageOptions: originalIngredient.storageOptions || {
              countertop: 'unknown',
              fridge: 'unknown',
              freezer: 'unknown'
            },
            isAntiInflammatory: originalIngredient.isAntiInflammatory || false,
            alt: originalIngredient.alt || ['fallback'],
            image: originalIngredient.image || ''
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to create ingredient variation after all retries');
  }

  /**
   * Generates a new unique ingredient of a specific type
   */
  async generateNewIngredient(type: 'protein' | 'vegetable' | 'fruit' | 'grain', existingTitles: string[]): Promise<EnhancedIngredientData> {
    const prompt = this.createNewIngredientGenerationPrompt(type, existingTitles);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseIngredientResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for new ingredient generation (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback new ingredient for type: ${type}`);
          return {
            title: `New ${type}`,
            type: type,
            calories: 0,
            macros: { protein: '0', carbs: '0', fat: '0' },
            categories: ['fallback'],
            features: {
              fiber: '0',
              g_i: '0',
              season: 'year-round',
              water: '0',
              rainbow: 'white'
            },
            techniques: ['fallback'],
            storageOptions: {
              countertop: 'unknown',
              fridge: 'unknown',
              freezer: 'unknown'
            },
            isAntiInflammatory: false,
            alt: ['fallback'],
            image: ''
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to generate new ingredient after all retries');
  }

  /**
   * Enhances an existing program with comprehensive details using Gemini AI
   */
  async enhanceExistingProgram(program: any): Promise<any> {
    const prompt = this.createExistingProgramEnhancementPrompt(program);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseProgramResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for existing program enhancement (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback response for existing program: ${program.name}`);
          return {
            name: program.name,
            type: program.type || 'Balanced',
            description: 'Fallback description',
            duration: '4 weeks',
            goals: ['Fallback goal'],
            mealPlan: {
              overview: 'Fallback meal plan',
              dailyStructure: 'Fallback structure',
              keyPrinciples: ['Fallback principle'],
              sampleMeals: ['Fallback meal']
            },
            fitnessProgram: {
              overview: 'Fallback fitness program',
              workoutTypes: ['Fallback workout'],
              frequency: '3 times per week',
              duration: '30 minutes',
              exercises: ['Fallback exercise']
            },
            guidelines: ['Fallback guideline'],
            benefits: ['Fallback benefit'],
            difficulty: 'Beginner',
            tips: ['Fallback tip'],
            notAllowed: ['snack'],
            portionDetails: {
              'fallback': {
                palmPercentage: 'unknown',
                spatulaSize: 'unknown',
                examples: ['fallback'],
                calories: '0'
              }
            }
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to enhance existing program after all retries');
  }

  /**
   * Enhances a program with portion details and not-allowed foods using Gemini AI
   */
  async enhanceProgramPortionDetails(program: any): Promise<{ notAllowed: string[]; portionDetails: Record<string, PortionDetail> }> {
    const prompt = this.createProgramPortionDetailsPrompt(program);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseProgramPortionDetailsResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for program portion details (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback response for program: ${program.name}`);
          return {
            notAllowed: ['snack'], // Use valid option instead of 'fallback'
            portionDetails: {
              'fallback': {
                palmPercentage: 'unknown',
                spatulaSize: 'unknown',
                examples: ['fallback'],
                calories: '0'
              }
            }
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to enhance program portion details after all retries');
  }

  /**
   * Creates comprehensive program details using Gemini AI
   */
  async createProgram(programType: Program['type']): Promise<any> {
    const prompt = this.createProgramPrompt(programType);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseProgramResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for program creation (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback response for program type: ${programType}`);
          return {
            name: `${programType} Program`,
            type: programType,
            description: `A comprehensive ${programType} program for health and wellness.`,
            duration: '4 weeks',
            goals: [`Achieve ${programType} goals`],
            mealPlan: {
              overview: `A structured meal plan for ${programType}`,
              dailyStructure: '3 main meals + 2 snacks',
              keyPrinciples: [`Focus on ${programType} principles`],
              sampleMeals: ['Sample meal 1', 'Sample meal 2']
            },
            fitnessProgram: {
              overview: `A fitness program designed for ${programType}`,
              workoutTypes: ['Cardio', 'Strength training'],
              frequency: '3 times per week',
              duration: '30 minutes',
              exercises: ['Exercise 1', 'Exercise 2']
            },
            guidelines: [`Follow ${programType} guidelines`],
            benefits: [`Experience ${programType} benefits`],
            difficulty: 'Beginner',
            tips: [`Tip for ${programType} success`],
            notAllowed: ['snack'],
            portionDetails: {
              'fallback': {
                palmPercentage: 'unknown',
                spatulaSize: 'unknown',
                examples: ['fallback'],
                calories: '0'
              }
            }
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to create program after all retries');
  }

  /**
   * Creates a daily routine for an existing program using Gemini AI
   */
  async createProgramRoutine(program: Program): Promise<any[]> {
    const prompt = this.createRoutinePrompt(program);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseRoutineResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for routine creation:', error);
      throw error;
    }
  }

  // Prompt creation methods (simplified versions)
  private createVariationPrompt(meal: Partial<Meal>, existingTitles: string[]): string {
    return `Create a unique variation of this meal: ${meal.title}. Existing titles to avoid: ${existingTitles.join(', ')}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "description": "string",
  "type": "string",
  "cookingTime": "string",
  "cookingMethod": "raw|frying|grilling|boiling|smoothie|roasting|mashing|baking|sautéing|soup",
  "ingredients": {
    "ingredient1": "amount with unit (e.g., '1 cup', '200g')",
    "ingredient2": "amount with unit"
  },
  "instructions": ["string"],
   "nutritionalInfo": {
        "calories": 0,
        "protein": 0,
        "carbs": 0,
        "fat": 0,
        "fiber": 0,
        "sugar": 0,
        "sodium": 0
      }
  "categories": ["string"],
  "serveQty": "string",
  "suggestions": {
    "improvements": ["suggestion1", "suggestion2"],
    "alternatives": ["alternative1", "alternative2"],
    "additions": ["addition1", "addition2"]
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "cookingMethod" must be one of: raw, frying, grilling, boiling, smoothie, roasting, mashing, baking, sautéing, soup
3. The "ingredients" object should contain ingredient names as keys and amounts with units as values (e.g., "tomatoes": "2 cups", "olive oil": "2 tablespoons")
4. The "suggestions" object must contain: improvements, alternatives, and additions arrays
5. Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createCookingMethodPrompt(cookingMethod: Partial<CookingMethod>): string {
    return `Enhance this cooking method: ${cookingMethod.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "howItWorks": "string",
  "equipment": ["string"],
  "bestFor": ["string"],
  "heatType": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createDietCategoryPrompt(category: Partial<DietCategory>): string {
    return `Enhance this diet category: ${category.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "kidsFriendly": boolean
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createEnhancementPrompt(meal: Partial<Meal>): string {
    return `Enhance this meal: ${meal.title}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "type": "string",
  "cookingTime": "string",
  "cookingMethod": "raw|frying|grilling|boiling|smoothie|roasting|mashing|baking|sautéing|soup",
  "ingredients": {
    "ingredient1": "amount with unit (e.g., '1 cup', '200g')",
    "ingredient2": "amount with unit"
  },
  "instructions": ["string"],
  "nutritionalInfo": {},
  "categories": ["string"],
  "serveQty": "string",
  "suggestions": {
    "improvements": ["suggestion1", "suggestion2"],
    "alternatives": ["alternative1", "alternative2"],
    "additions": ["addition1", "addition2"]
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "cookingMethod" must be one of: raw, frying, grilling, boiling, smoothie, roasting, mashing, baking, sautéing, soup
3. The "ingredients" object should contain ingredient names as keys and amounts with units as values (e.g., "tomatoes": "2 cups", "olive oil": "2 tablespoons")
4. The "suggestions" object must contain: improvements, alternatives, and additions arrays
5. Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createIngredientVariationPrompt(ingredient: Partial<Ingredient>, existingTitles: string[]): string {
    return `Create a unique variation of this ingredient: ${ingredient.title}. Existing titles to avoid: ${existingTitles.join(', ')}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "string", 
  "calories": number,
  "macros": {
    "protein": "string",
    "carbs": "string",
    "fat": "string"
  },
  "categories": ["string"],
  "features": {
    "fiber": "string",
    "g_i": "string",
    "season": "string",
    "water": "string",
    "rainbow": "string"
  },
  "techniques": [
    "string"
  ],
  "storageOptions": {
    "countertop": "string",
    "fridge": "string",
    "freezer": "string"
  },
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "title" should be a simple ingredient name (e.g., "kale", "braised kale", "roasted broccoli") - NOT a meal description like "Massaged Kale with Lemon-Ginger Zing"
3. The "features" object must ONLY contain: fiber, g_i, rainbow, season, water
4. The "techniques" array must contain objects with from this exact list:
   - "raw"
   - "frying"
   - "grilling"
   - "boiling"
   - "smoothie"
   - "roasting"
   - "mashing"
   - "baking"
   - "sautéing"
   - "soup"
5. The "storageOptions" object must ONLY contain: countertop, fridge, freezer
6. "rainbow" should be the ingredient color (e.g., "green" for broccoli, "red" for tomatoes)
7. The response should be valid JSON that can be parsed directly.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createNewIngredientGenerationPrompt(type: 'protein' | 'vegetable' | 'fruit' | 'grain', existingTitles: string[]): string {
    return `Generate a new unique ${type} ingredient. Existing titles to avoid: ${existingTitles.join(', ')}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "${type}", 
  "calories": number,
  "macros": {
    "protein": "string",
    "carbs": "string",
    "fat": "string"
  },
  "categories": ["string"],
  "features": {
    "fiber": "string",
    "g_i": "string",
    "season": "string",
    "water": "string",
    "rainbow": "string"
  },
  "techniques": [
    "string"
  ],
  "storageOptions": {
    "countertop": "string",
    "fridge": "string",
    "freezer": "string"
  },
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "title" should be a simple ingredient name (e.g., "kale", "braised kale", "roasted broccoli") - NOT a meal description like "Massaged Kale with Lemon-Ginger Zing"
3. The "features" object must ONLY contain: fiber, g_i, rainbow, season, water
4. The "techniques" array must contain objects with from this exact list:
   - "raw"
   - "frying"
   - "grilling"
   - "boiling"
   - "smoothie"
   - "roasting"
   - "mashing"
   - "baking"
   - "sautéing"
   - "soup"
5. The "storageOptions" object must ONLY contain: countertop, fridge, freezer
6. "rainbow" should be the ingredient color (e.g., "green" for broccoli, "red" for tomatoes)
7. The response should be valid JSON that can be parsed directly.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private shouldRenameIngredient(title: string): boolean {
    const lowerTitle = title.toLowerCase();
    return lowerTitle.includes('ingredient') || 
           lowerTitle.includes('food') || 
           lowerTitle.includes('item') ||
           lowerTitle.includes('product');
  }

  private validateAndCorrectTechniques(techniques: any): string[] {
    const allowedTechniques = [
      'raw', 'frying', 'grilling', 'boiling', 'smoothie', 
      'roasting', 'mashing', 'baking', 'sautéing', 'soup'
    ];

    if (!Array.isArray(techniques)) {
      console.log('Techniques is not an array, using fallback');
      return ['raw'];
    }

    const validTechniques = techniques.filter(tech => {
      if (typeof tech === 'string') {
        return allowedTechniques.includes(tech);
      } else if (typeof tech === 'object' && tech.name) {
        return allowedTechniques.includes(tech.name);
      }
      return false;
    });

    if (validTechniques.length === 0) {
      console.log('No valid techniques found, using fallback');
      return ['raw'];
    }

    // Convert to simple strings if they were objects
    return validTechniques.map(tech => typeof tech === 'string' ? tech : tech.name);
  }

  private validateAndCorrectFeatures(features: any): {
    fiber: string;
    g_i: string;
    season: 'spring' | 'summer' | 'autumn' | 'winter' | 'year-round' | 'fall/winter' | 'spring/summer';
    water: string;
    rainbow: 'red' | 'orange' | 'yellow' | 'green' | 'blue' | 'purple' | 'white' | 'brown' | 'pink' | 'black';
  } {
    const requiredFeatures = ['fiber', 'g_i', 'season', 'water', 'rainbow'];
    const fallbackFeatures = {
      fiber: 'low',
      g_i: 'low',
      season: 'year-round' as const,
      water: 'low',
      rainbow: 'white' as const
    };

    if (!features || typeof features !== 'object') {
      console.log('Features is not an object, using fallback');
      return fallbackFeatures;
    }

    const correctedFeatures: typeof fallbackFeatures = { ...fallbackFeatures };
    
    for (const feature of requiredFeatures) {
      if (features[feature] && typeof features[feature] === 'string') {
        if (feature === 'season') {
          const seasonValue = features[feature];
          if (['spring', 'summer', 'autumn', 'winter', 'year-round', 'fall/winter', 'spring/summer'].includes(seasonValue)) {
            correctedFeatures.season = seasonValue as any;
          }
        } else if (feature === 'rainbow') {
          const rainbowValue = features[feature];
          if (['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'white', 'brown', 'pink', 'black'].includes(rainbowValue)) {
            correctedFeatures.rainbow = rainbowValue as any;
          }
        } else if (feature === 'fiber' || feature === 'g_i' || feature === 'water') {
          correctedFeatures[feature] = features[feature];
        }
      }
    }

    return correctedFeatures;
  }

  private validateAndCorrectStorageOptions(storageOptions: any): {
    countertop: string;
    fridge: string;
    freezer: string;
  } {
    const requiredStorage = ['countertop', 'fridge', 'freezer'];
    const fallbackStorage = {
      countertop: 'not recommended',
      fridge: 'recommended',
      freezer: 'not recommended'
    };

    if (!storageOptions || typeof storageOptions !== 'object') {
      console.log('StorageOptions is not an object, using fallback');
      return fallbackStorage;
    }

    const correctedStorage = { ...fallbackStorage };
    
    for (const storage of requiredStorage) {
      if (storageOptions[storage] && typeof storageOptions[storage] === 'string') {
        correctedStorage[storage as keyof typeof correctedStorage] = storageOptions[storage];
      }
    }

    return correctedStorage;
  }

  async renameIngredient(ingredient: Partial<Ingredient>): Promise<string> {
    const maxRetries = 3;
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`Renaming ingredient: ${ingredient.title} (attempt ${attempt})`);
        const prompt = this.createIngredientRenamingPrompt(ingredient);
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }
        
        // Parse the response to get the new title
        const cleanedResponse = this.fixCommonJsonIssues(generatedText.replace(/```json\s*|\s*```/g, ''));
        const parsed = JSON.parse(cleanedResponse);
        
        if (parsed.title && typeof parsed.title === 'string') {
          return parsed.title;
        } else {
          throw new Error('Invalid response format: missing or invalid title');
        }
      } catch (error) {
        console.error(`Error calling Gemini API for ingredient renaming (attempt ${attempt}):`, error);
        lastError = error as Error;
        
        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
          console.log(`Retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    console.error('All retry attempts failed for ingredient renaming, using fallback');
    // Fallback: try to extract a meaningful name from the original title
    const originalTitle = ingredient.title || 'Unknown Ingredient';
    const cleanedTitle = originalTitle
      .replace(/ingredient/gi, '')
      .replace(/food/gi, '')
      .replace(/item/gi, '')
      .replace(/product/gi, '')
      .trim();
    
    return cleanedTitle || 'Unknown Ingredient';
  }

  private createIngredientRenamingPrompt(ingredient: Partial<Ingredient>): string {
    return `Rename this ingredient: "${ingredient.title}". 

The current name contains generic words like "ingredient", "food", "item", or "product". Please provide a proper, specific ingredient name.

Return a valid JSON object with ONLY the new title:

{
  "title": "string"
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "title" should be a simple, specific ingredient name (e.g., "kale", "broccoli", "chicken breast", "quinoa")
3. Remove any generic words like "ingredient", "food", "item", "product"
4. Keep it simple and descriptive of the actual ingredient
5. The response should be valid JSON that can be parsed directly.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createIngredientEnhancementPrompt(ingredient: Partial<Ingredient>): string {
    return `Enhance this ingredient: ${ingredient.title}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "string", 
  "calories": number,
  "macros": {
    "protein": "string",
    "carbs": "string",
    "fat": "string"
  },
  "categories": ["string"],
  "features": {
    "fiber": "string (e.g., '10g')",
    "g_i": "string (e.g., '40', 'low', 'medium', 'high')",
    "season": "spring|summer|autumn|winter|year-round|fall/winter|spring/summer",
    "water": "string (e.g., '10%')",
    "rainbow": "red|orange|yellow|green|blue|purple|white|brown|pink|black"
  },
  "techniques": [
    "string"
  ],
  "storageOptions": {
    "countertop": "string",
    "fridge": "string",
    "freezer": "string"
  },
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "title" should be a simple ingredient name (e.g., "kale", "braised kale", "roasted broccoli") - NOT a meal description like "Massaged Kale with Lemon-Ginger Zing"
3. The "features" object must ONLY contain: fiber, g_i, rainbow, season, water
4. The "techniques" array must contain objects with from this exact list:
   - "raw"
   - "frying"
   - "grilling"
   - "boiling"
   - "smoothie"
   - "roasting"
   - "mashing"
   - "baking"
   - "sautéing"
   - "soup"
5. The "storageOptions" object must ONLY contain: countertop, fridge, freezer
6. "rainbow" must be one of: red, orange, yellow, green, blue, purple, white, brown, pink, black (NOT a number)
7. "season" must be one of: spring, summer, autumn, winter, year-round, fall/winter, spring/summer
8. "fiber" should include units when possible (e.g., "10g", "high", "low")
9. "g_i" should be the glycemic index number or category (e.g., "40", "low", "medium", "high")
10. "water" should include percentage when possible (e.g., "10%", "high", "low")
11. The response should be valid JSON that can be parsed directly.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createExistingProgramEnhancementPrompt(program: Program): string {
    return `Enhance this existing program: ${program.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "name": "${program.name}",
  "type": "${program.type || 'Balanced'}",
  "description": "string",
  "duration": "string",
  "goals": ["string"],
  "mealPlan": {
    "overview": "string",
    "dailyStructure": "string",
    "keyPrinciples": ["string"],
    "sampleMeals": ["string"]
  },
  "fitnessProgram": {
    "overview": "string",
    "workoutTypes": ["string"],
    "frequency": "string",
    "duration": "string",
    "exercises": ["string"]
  },
  "guidelines": ["string"],
  "benefits": ["string"],
  "difficulty": "Beginner|Intermediate|Advanced",
  "tips": ["string"],
  "notAllowed": ["string"],
  "portionDetails": {
    "foodCategory": {
      "palmPercentage": "string",
      "spatulaSize": "string",
      "examples": ["string"],
      "calories": "string"
    }
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "notAllowed" array can ONLY contain these 4 options: "snack", "fruit", "dessert", "alcohol"
3. Choose the most appropriate option(s) based on the program's focus and goals.
4. The response should be valid JSON that can be parsed directly.
5. Keep the existing program name and type, but enhance all other fields.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createProgramPortionDetailsPrompt(program: Program): string {
    return `Enhance this program: ${program.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "notAllowed": ["string"],
  "portionDetails": {
    "foodCategory": {
      "palmPercentage": "string",
      "spatulaSize": "string",
      "examples": ["string"],
      "calories": "string"
    }
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "notAllowed" array can ONLY contain these 4 options: "snack", "fruit", "dessert", "alcohol"
3. Choose the most appropriate option(s) based on the program's focus and goals.
4. The response should be valid JSON that can be parsed directly.

Example structure for portionDetails:
- "protein": {"palmPercentage": "1 palm", "spatulaSize": "1 spatula", "examples": ["chicken", "fish"], "calories": "300"}
- "vegetables": {"palmPercentage": "2 palms", "spatulaSize": "2 spatulas", "examples": ["broccoli", "spinach"], "calories": "100"}
- "fruits": {"palmPercentage": "1 palm", "spatulaSize": "1 spatula", "examples": ["apple", "banana"], "calories": "80"}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createProgramPrompt(programType: Program['type']): string {
    return `Create a comprehensive program for type: ${programType}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "name": "string",
  "description": "string",
  "duration": "string",
  "goals": ["string"],
  "mealPlan": "string",
  "fitnessProgram": "string",
  "guidelines": ["string"],
  "benefits": ["string"],
  "difficulty": "string",
  "tips": ["string"],
  "notAllowed": ["string"],
  "portionDetails": {
    "foodCategory": {
      "palmPercentage": "string",
      "spatulaSize": "string",
      "examples": ["string"],
      "calories": "string"
    }
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "notAllowed" array can ONLY contain these 4 options: "snack", "fruit", "dessert", "alcohol"
3. Choose the most appropriate option(s) based on the program type and goals.
4. The response should be valid JSON that can be parsed directly.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createRoutinePrompt(program: Program): string {
    return `Create a daily routine for program: ${program.name}. 

Return a valid JSON array with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

[
  {
    "title": "string",
    "duration": "string",
    "description": "string"
  }
]

IMPORTANT: Return ONLY the JSON array. Do not include any code examples, explanations, or other text. The response should be valid JSON that can be parsed directly.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  // Response parsing methods (simplified versions)
  private parseVariationResponse(response: string): MealVariation {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        title: parsed.title || 'Untitled Variation',
        description: parsed.description,
        type: parsed.type,
        cookingTime: parsed.cookingTime,
        cookingMethod: parsed.cookingMethod,
        ingredients: parsed.ingredients || {},
        instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
        nutritionalInfo: parsed.nutritionalInfo,
        categories: Array.isArray(parsed.categories) ? parsed.categories : [],
        serveQty: parsed.serveQty,
        suggestions: parsed.suggestions
      };
    } catch (error) {
      console.error('Error parsing variation response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse variation response');
    }
  }

  private parseCookingMethodResponse(response: string): EnhancedCookingMethod {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        description: parsed.description || 'No description available',
        howItWorks: parsed.howItWorks || 'No details available',
        equipment: Array.isArray(parsed.equipment) ? parsed.equipment : [],
        bestFor: Array.isArray(parsed.bestFor) ? parsed.bestFor : [],
        heatType: parsed.heatType || 'Unknown heat type'
      };
    } catch (error) {
      console.error('Error parsing cooking method response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse cooking method response');
    }
  }

  private parseDietCategoryResponse(response: string): EnhancedDietCategory {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        description: parsed.description || 'No description available',
        kidsFriendly: typeof parsed.kidsFriendly === 'boolean' ? parsed.kidsFriendly : false
      };
    } catch (error) {
      console.error('Error parsing diet category response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse diet category response');
    }
  }

  private parseGeminiResponse(response: string): EnhancedMealData {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        description: parsed.description,
        type: parsed.type,
        cookingTime: parsed.cookingTime,
        cookingMethod: parsed.cookingMethod,
        ingredients: parsed.ingredients || {},
        instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
        nutritionalInfo: parsed.nutritionalInfo,
        categories: Array.isArray(parsed.categories) ? parsed.categories : [],
        serveQty: parsed.serveQty,
        suggestions: parsed.suggestions
      };
    } catch (error) {
      console.error('Error parsing Gemini response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse Gemini response');
    }
  }

  private parseIngredientResponse(response: string): EnhancedIngredientData {
    try {
      console.log('Raw Gemini response:', response.substring(0, 500) + '...');
      
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      console.log('Cleaned JSON:', cleanedResponse.substring(0, 500) + '...');
      
      const parsed = JSON.parse(cleanedResponse);
      
      // Validate and correct the data structure
      const validatedFeatures = this.validateAndCorrectFeatures(parsed.features);
      const validatedTechniques = this.validateAndCorrectTechniques(parsed.techniques);
      const validatedStorageOptions = this.validateAndCorrectStorageOptions(parsed.storageOptions);
      
      return {
        title: parsed.title,
        type: parsed.type,
        calories: parsed.calories,
        macros: parsed.macros,
        categories: Array.isArray(parsed.categories) ? parsed.categories : [],
        features: validatedFeatures,
        techniques: validatedTechniques,
        storageOptions: validatedStorageOptions,
        isAntiInflammatory: parsed.isAntiInflammatory,
        alt: Array.isArray(parsed.alt) ? parsed.alt : [],
        image: parsed.image
      };
    } catch (error) {
      console.error('Error parsing ingredient response:', error);
      console.error('Raw response:', response);
      
      // Try to extract the ingredient title from the response for fallback
      const titleMatch = response.match(/ingredient:\s*([^\n,]+)/i) || 
                        response.match(/title["\s]*:\s*["']?([^"'\n,]+)/i) ||
                        response.match(/enhance.*?:\s*([^\n,]+)/i);
      
      const ingredientTitle = titleMatch ? titleMatch[1].trim() : 'Unknown Ingredient';
      
      console.log(`Creating fallback response for ingredient: ${ingredientTitle}`);
      
      // Return a basic fallback response
      return {
        title: ingredientTitle,
        type: 'vegetable', // Default to vegetable as a safe fallback
        calories: 0,
        macros: { protein: '0', carbs: '0', fat: '0' },
        categories: ['fallback'],
        features: {
          fiber: 'low',
          g_i: 'low',
          season: 'year-round',
          water: 'low',
          rainbow: 'white'
        },
        techniques: ['fallback'],
        storageOptions: {
          countertop: 'unknown',
          fridge: 'unknown',
          freezer: 'unknown'
        },
        isAntiInflammatory: false,
        alt: ['fallback'],
        image: ''
      };
    }
  }

  /**
   * Fixes common JSON formatting issues that AI models often produce
   */
  private fixCommonJsonIssues(jsonString: string): string {
    // Remove any leading/trailing text that's not JSON
    let cleaned = jsonString.trim();
    
    // Fix unquoted property names (more comprehensive)
    cleaned = cleaned.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
    
    // Fix single quotes to double quotes
    cleaned = cleaned.replace(/'/g, '"');
    
    // Fix trailing commas
    cleaned = cleaned.replace(/,(\s*[}\]])/g, '$1');
    
    // Fix boolean values that might be strings
    cleaned = cleaned.replace(/"true"/g, 'true');
    cleaned = cleaned.replace(/"false"/g, 'false');
    
    // Fix numeric values that might be strings
    cleaned = cleaned.replace(/"(\d+(?:\.\d+)?)"/g, '$1');
    
    // Fix escaped quotes within strings
    cleaned = cleaned.replace(/\\"/g, '"');
    
    // Fix newlines and tabs within strings
    cleaned = cleaned.replace(/\\n/g, ' ');
    cleaned = cleaned.replace(/\\t/g, ' ');
    
    // Fix multiple spaces
    cleaned = cleaned.replace(/\s+/g, ' ');
    
    // Fix missing closing braces/brackets
    const openBraces = (cleaned.match(/\{/g) || []).length;
    const closeBraces = (cleaned.match(/\}/g) || []).length;
    const openBrackets = (cleaned.match(/\[/g) || []).length;
    const closeBrackets = (cleaned.match(/\]/g) || []).length;
    
    // Add missing closing braces
    for (let i = 0; i < openBraces - closeBraces; i++) {
      cleaned += '}';
    }
    
    // Add missing closing brackets
    for (let i = 0; i < openBrackets - closeBrackets; i++) {
      cleaned += ']';
    }
    
    return cleaned;
  }

  private parseProgramPortionDetailsResponse(response: string): { notAllowed: string[]; portionDetails: Record<string, PortionDetail> } {
    try {
      console.log('Raw program response:', response.substring(0, 500) + '...');
      
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // First, try to parse the JSON as-is to see if it's already valid
      try {
        const parsed = JSON.parse(cleanedResponse);
        console.log('JSON parsed successfully without cleaning');
        return {
          notAllowed: Array.isArray(parsed.notAllowed) ? parsed.notAllowed : [],
          portionDetails: parsed.portionDetails || {}
        };
      } catch (initialError) {
        console.log('Initial JSON parsing failed, attempting to fix...');
      }
      
      // If initial parsing failed, try to fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      console.log('Cleaned program JSON:', cleanedResponse.substring(0, 500) + '...');
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        notAllowed: Array.isArray(parsed.notAllowed) ? parsed.notAllowed : [],
        portionDetails: parsed.portionDetails || {}
      };
    } catch (error) {
      console.error('Error parsing program portion details response:', error);
      console.error('Raw response:', response);
      
      // Try to extract program name from the response for fallback
      const programMatch = response.match(/program.*?:\s*["']?([^"'\n,]+)/i) || 
                          response.match(/enhance.*?:\s*["']?([^"'\n,]+)/i);
      
      const programName = programMatch ? programMatch[1].trim() : 'Unknown Program';
      
      console.log(`Creating fallback response for program: ${programName}`);
      
      // Return a basic fallback response
      return {
        notAllowed: ['snack'], // Use valid option instead of 'fallback'
        portionDetails: {
          'fallback': {
            palmPercentage: 'unknown',
            spatulaSize: 'unknown',
            examples: ['fallback'],
            calories: '0'
          }
        }
      };
    }
  }

  private parseProgramResponse(response: string): any {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return parsed;
    } catch (error) {
      console.error('Error parsing program response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse program response');
    }
  }

  private parseRoutineResponse(response: string): any[] {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.error('Error parsing routine response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse routine response');
    }
  }

  /**
   * Updates the ingredient type based on title and macros analysis
   * Allows 12 types: protein, grain, vegetable, fruit, sweetener, condiment, pastry, dairy, oil, herb, spice, liquid
   */
  async updateIngredientType(ingredient: Partial<Ingredient>): Promise<'protein' | 'grain' | 'vegetable' | 'fruit' | 'sweetener' | 'condiment' | 'pastry' | 'dairy' | 'oil' | 'herb' | 'spice' | 'liquid'> {
    const prompt = this.createIngredientTypeClassificationPrompt(ingredient);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseIngredientTypeResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for ingredient type classification (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, use fallback logic based on macros
          console.log(`Using fallback classification for ingredient: ${ingredient.title}`);
          return this.fallbackIngredientTypeClassification(ingredient);
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to classify ingredient type after all retries');
  }

  private createIngredientTypeClassificationPrompt(ingredient: Partial<Ingredient>): string {
    const title = ingredient.title || 'Unknown';
    const calories = ingredient.calories || 0;
    const protein = ingredient.macros?.protein || '0';
    const carbs = ingredient.macros?.carbs || '0';
    const fat = ingredient.macros?.fat || '0';

    return `Analyze this ingredient and classify it into one of the 12 allowed types based on its title and nutritional macros.

Ingredient: ${title}
Calories: ${calories}
Protein: ${protein}g
Carbs: ${carbs}g
Fat: ${fat}g

Allowed types:
1. "protein" - High protein foods like meat, fish, eggs, legumes
2. "grain" - Carbohydrate-rich foods like rice, wheat, oats, quinoa, bread, pasta
3. "vegetable" - Plant-based foods that are not sweet, like broccoli, spinach, carrots, peppers
4. "fruit" - Sweet plant-based foods like apples, bananas, berries, oranges
5. "sweetener" - Sugar, honey, maple syrup, artificial sweeteners
6. "condiment" - Sauces, dressings, spreads like ketchup, mustard, mayo, salsa
7. "pastry" - Baked goods like cakes, cookies, pies, croissants
8. "dairy" - Milk, cheese, yogurt, butter, cream
9. "oil" - Cooking oils, olive oil, coconut oil, vegetable oil
10. "herb" - Fresh or dried herbs like basil, thyme, rosemary, cilantro
11. "spice" - Spices and seasonings like salt, pepper, cinnamon, paprika
12. "liquid" - Beverages, broths, juices, water-based ingredients

Classification rules:
- Consider the title name as the primary indicator
- Use macros as secondary validation
- Be specific and accurate in classification

Return ONLY one of these exact strings: "protein", "grain", "vegetable", "fruit", "sweetener", "condiment", "pastry", "dairy", "oil", "herb", "spice", or "liquid"
Do not include any explanations, quotes, or additional text.`;
  }

  private parseIngredientTypeResponse(response: string): 'protein' | 'grain' | 'vegetable' | 'fruit' | 'sweetener' | 'condiment' | 'pastry' | 'dairy' | 'oil' | 'herb' | 'spice' | 'liquid' {
    try {
      // Clean the response
      let cleanedResponse = response.trim().toLowerCase();
      
      // Remove quotes if present
      cleanedResponse = cleanedResponse.replace(/['"]/g, '');
      
      // Check if it's one of the valid types
      const validTypes = ['protein', 'grain', 'vegetable', 'fruit', 'sweetener', 'condiment', 'pastry', 'dairy', 'oil', 'herb', 'spice', 'liquid'];
      
      if (validTypes.includes(cleanedResponse)) {
        return cleanedResponse as 'protein' | 'grain' | 'vegetable' | 'fruit' | 'sweetener' | 'condiment' | 'pastry' | 'dairy' | 'oil' | 'herb' | 'spice' | 'liquid';
      }
      
      // If not a valid type, throw error to trigger fallback
      throw new Error(`Invalid ingredient type: ${cleanedResponse}`);
    } catch (error) {
      console.error('Error parsing ingredient type response:', error);
      throw error;
    }
  }

  private fallbackIngredientTypeClassification(ingredient: Partial<Ingredient>): 'protein' | 'grain' | 'vegetable' | 'fruit' | 'sweetener' | 'condiment' | 'pastry' | 'dairy' | 'oil' | 'herb' | 'spice' | 'liquid' {
    const title = (ingredient.title || '').toLowerCase();
    const protein = parseFloat(ingredient.macros?.protein || '0');
    const carbs = parseFloat(ingredient.macros?.carbs || '0');
    const fat = parseFloat(ingredient.macros?.fat || '0');
    
    // Calculate percentages
    const totalCalories = protein * 4 + carbs * 4 + fat * 9;
    const proteinPercentage = totalCalories > 0 ? (protein * 4 / totalCalories) * 100 : 0;
    const carbsPercentage = totalCalories > 0 ? (carbs * 4 / totalCalories) * 100 : 0;
    
    // Sweetener classification
    if (title.includes('sugar') || title.includes('honey') || title.includes('syrup') ||
        title.includes('sweetener') || title.includes('stevia') || title.includes('agave') ||
        title.includes('maple') || title.includes('molasses')) {
      return 'sweetener';
    }
    
    // Condiment classification
    if (title.includes('sauce') || title.includes('dressing') || title.includes('ketchup') ||
        title.includes('mustard') || title.includes('mayo') || title.includes('salsa') ||
        title.includes('hot sauce') || title.includes('soy sauce') || title.includes('vinegar')) {
      return 'condiment';
    }
    
    // Pastry classification
    if (title.includes('cake') || title.includes('cookie') || title.includes('pie') ||
        title.includes('pastry') || title.includes('croissant') || title.includes('muffin') ||
        title.includes('brownie') || title.includes('donut') || title.includes('bread')) {
      return 'pastry';
    }
    
    // Dairy classification
    if (title.includes('milk') || title.includes('cheese') || title.includes('yogurt') ||
        title.includes('butter') || title.includes('cream') || title.includes('sour cream') ||
        title.includes('cottage cheese') || title.includes('cream cheese')) {
      return 'dairy';
    }
    
    // Oil classification
    if (title.includes('oil') || title.includes('olive') || title.includes('coconut') ||
        title.includes('vegetable oil') || title.includes('canola') || title.includes('sesame')) {
      return 'oil';
    }
    
    // Herb classification
    if (title.includes('basil') || title.includes('thyme') || title.includes('rosemary') ||
        title.includes('cilantro') || title.includes('parsley') || title.includes('oregano') ||
        title.includes('sage') || title.includes('mint') || title.includes('dill')) {
      return 'herb';
    }
    
    // Spice classification
    if (title.includes('salt') || title.includes('pepper') || title.includes('cinnamon') ||
        title.includes('paprika') || title.includes('cumin') || title.includes('turmeric') ||
        title.includes('ginger') || title.includes('garlic') || title.includes('onion') ||
        title.includes('spice') || title.includes('seasoning')) {
      return 'spice';
    }
    
    // Liquid classification
    if (title.includes('water') || title.includes('juice') || title.includes('broth') ||
        title.includes('stock') || title.includes('tea') || title.includes('coffee') ||
        title.includes('soda') || title.includes('milk') || title.includes('wine') ||
        title.includes('beer') || title.includes('liquor')) {
      return 'liquid';
    }
    
    // Protein classification
    if (proteinPercentage > 50 || 
        title.includes('chicken') || title.includes('beef') || title.includes('pork') ||
        title.includes('fish') || title.includes('salmon') || title.includes('tuna') ||
        title.includes('egg') || title.includes('tofu') || title.includes('tempeh') ||
        title.includes('lentil') || title.includes('bean') || title.includes('chickpea')) {
      return 'protein';
    }
    
    // Grain classification
    if (carbsPercentage > 60 || 
        title.includes('rice') || title.includes('pasta') || title.includes('quinoa') ||
        title.includes('oats') || title.includes('wheat') || title.includes('corn') ||
        title.includes('potato') || title.includes('sweet potato')) {
      return 'grain';
    }
    
    // Fruit classification
    if (title.includes('apple') || title.includes('banana') || title.includes('berry') ||
        title.includes('orange') || title.includes('grape') || title.includes('mango') ||
        title.includes('pineapple') || title.includes('strawberry') || title.includes('blueberry') ||
        title.includes('peach') || title.includes('pear') || title.includes('plum')) {
      return 'fruit';
    }
    
    // Default to vegetable
    return 'vegetable';
  }
}
