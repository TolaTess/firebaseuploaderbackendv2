import { Meal } from '../types/meal';
import { CookingMethod, DietCategory, Program, PortionDetail } from '../types/collections';
import { Ingredient } from '../types/ingredient';

interface EnhancedMealData {
  description?: string;
  type?: 'protein' | 'grain' | 'vegetable' | 'fruit';
  cookingTime?: string;
  cookingMethod?: string;
  ingredients?: Record<string, string>;
  instructions?: string[];
  nutritionalInfo?: {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  };
  categories?: string[];
  serveQty?: number;
  suggestions?: {
    improvements: string[];
    alternatives: string[];
    additions: string[];
  };
}

interface MealVariation {
  title: string;
  description?: string;
  type?: 'protein' | 'grain' | 'vegetable' | 'fruit';
  cookingTime?: string;
  cookingMethod?: string;
  ingredients?: Record<string, string>;
  instructions?: string[];
  nutritionalInfo?: {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  };
  categories?: string[];
  serveQty?: number;
  suggestions?: {
    improvements: string[];
    alternatives: string[];
    additions: string[];
  };
}

interface EnhancedCookingMethod {
  description: string;
  howItWorks: string;
  equipment: string[];
  bestFor: string[];
  heatType: string;
}

interface EnhancedDietCategory {
  description: string;
  kidsFriendly: boolean;
}

interface EnhancedIngredientData {
  title?: string;
  type?: 'protein' | 'vegetable' | 'fruit' | 'grain' | 'sweetener' | 'condiment' | 'pastry';
  calories?: number;
  macros?: {
    protein: string;
    carbs: string;
    fat: string;
  };
  categories?: string[];
  features?: {
    fiber: string;
    g_i: string;
    season: string;
    water: string;
    rainbow: string;
  };
  techniques?: string[];
  storageOptions?: {
    countertop: string;
    fridge: string;
    freezer: string;
  };
  isAntiInflammatory?: boolean;
  alt?: string[];
  image?: string;
}

export class GeminiService {
  private apiKey: string;
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';

  constructor() {
    this.apiKey = process.env.VITE_GEMINI_API_KEY || '';
    if (!this.apiKey) {
      throw new Error('VITE_GEMINI_API_KEY environment variable is required');
    }
  }

  /**
   * Transforms a duplicate meal into a unique variation
   */
  async createMealVariation(originalMeal: Partial<Meal>, existingTitles: string[]): Promise<MealVariation> {
    const prompt = this.createVariationPrompt(originalMeal, existingTitles);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseVariationResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for variation:', error);
      throw error;
    }
  }

  /**
   * Enhances cooking method details using Gemini AI
   */
  async enhanceCookingMethod(cookingMethod: Partial<CookingMethod>): Promise<EnhancedCookingMethod> {
    const prompt = this.createCookingMethodPrompt(cookingMethod);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseCookingMethodResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for cooking method:', error);
      throw error;
    }
  }

  /**
   * Enhances diet category details using Gemini AI
   */
  async enhanceDietCategory(category: Partial<DietCategory>): Promise<EnhancedDietCategory> {
    const prompt = this.createDietCategoryPrompt(category);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseDietCategoryResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for diet category:', error);
      throw error;
    }
  }

  /**
   * Enhances meal data using Gemini AI
   */
  async enhanceMealDetails(meal: Partial<Meal>): Promise<EnhancedMealData> {
    const prompt = this.createEnhancementPrompt(meal);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseGeminiResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API:', error);
      throw error;
    }
  }

  /**
   * Enhances ingredient with complete details using Gemini AI
   */
  async enhanceIngredientDetails(ingredient: Partial<Ingredient>): Promise<EnhancedIngredientData> {
    const prompt = this.createIngredientEnhancementPrompt(ingredient);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseIngredientResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for ingredient enhancement:', error);
      throw error;
    }
  }

  /**
   * Creates an ingredient variation using Gemini AI
   */
  async createIngredientVariation(originalIngredient: Partial<Ingredient>, existingTitles: string[]): Promise<EnhancedIngredientData> {
    const prompt = this.createIngredientVariationPrompt(originalIngredient, existingTitles);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseIngredientResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for ingredient variation:', error);
      throw error;
    }
  }

  /**
   * Generates a new unique ingredient of a specific type
   */
  async generateNewIngredient(type: 'protein' | 'vegetable' | 'fruit' | 'grain', existingTitles: string[]): Promise<EnhancedIngredientData> {
    const prompt = this.createNewIngredientGenerationPrompt(type, existingTitles);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseIngredientResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for new ingredient generation:', error);
      throw error;
    }
  }

  /**
   * Enhances a program with portion details and not-allowed foods using Gemini AI
   */
  async enhanceProgramPortionDetails(program: any): Promise<{ notAllowed: string[]; portionDetails: Record<string, PortionDetail> }> {
    const prompt = this.createProgramPortionDetailsPrompt(program);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseProgramPortionDetailsResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for program portion details:', error);
      throw error;
    }
  }

  /**
   * Creates comprehensive program details using Gemini AI
   */
  async createProgram(programType: Program['type']): Promise<any> {
    const prompt = this.createProgramPrompt(programType);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseProgramResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for program creation:', error);
      throw error;
    }
  }

  /**
   * Creates a daily routine for an existing program using Gemini AI
   */
  async createProgramRoutine(program: Program): Promise<any[]> {
    const prompt = this.createRoutinePrompt(program);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseRoutineResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for routine creation:', error);
      throw error;
    }
  }

  // Prompt creation methods (simplified versions)
  private createVariationPrompt(meal: Partial<Meal>, existingTitles: string[]): string {
    return `Create a unique variation of this meal: ${meal.title}. Existing titles to avoid: ${existingTitles.join(', ')}. Return JSON with title, description, type, cookingTime, cookingMethod, ingredients, instructions, nutritionalInfo, categories, serveQty, and suggestions.`;
  }

  private createCookingMethodPrompt(cookingMethod: Partial<CookingMethod>): string {
    return `Enhance this cooking method: ${cookingMethod.name}. Return JSON with description, howItWorks, equipment, bestFor, and heatType.`;
  }

  private createDietCategoryPrompt(category: Partial<DietCategory>): string {
    return `Enhance this diet category: ${category.name}. Return JSON with description and kidsFriendly boolean.`;
  }

  private createEnhancementPrompt(meal: Partial<Meal>): string {
    return `Enhance this meal: ${meal.title}. Return JSON with description, type, cookingTime, cookingMethod, ingredients, instructions, nutritionalInfo, categories, serveQty, and suggestions.`;
  }

  private createIngredientVariationPrompt(ingredient: Partial<Ingredient>, existingTitles: string[]): string {
    return `Create a unique variation of this ingredient: ${ingredient.title}. Existing titles to avoid: ${existingTitles.join(', ')}. Return JSON with title, type, calories, macros, categories, features, techniques, storageOptions, isAntiInflammatory, alt, and image.`;
  }

  private createNewIngredientGenerationPrompt(type: 'protein' | 'vegetable' | 'fruit' | 'grain', existingTitles: string[]): string {
    return `Generate a new unique ${type} ingredient. Existing titles to avoid: ${existingTitles.join(', ')}. Return JSON with title, type, calories, macros, categories, features, techniques, storageOptions, isAntiInflammatory, alt, and image.`;
  }

  private createIngredientEnhancementPrompt(ingredient: Partial<Ingredient>): string {
    return `Enhance this ingredient: ${ingredient.title}. Return JSON with title, type, calories, macros, categories, features, techniques, storageOptions, isAntiInflammatory, alt, and image.`;
  }

  private createProgramPortionDetailsPrompt(program: Program): string {
    return `Enhance this program: ${program.name}. Return JSON with notAllowed array and portionDetails object.`;
  }

  private createProgramPrompt(programType: Program['type']): string {
    return `Create a comprehensive program for type: ${programType}. Return JSON with name, description, duration, goals, mealPlan, fitnessProgram, guidelines, benefits, difficulty, tips, notAllowed, and portionDetails.`;
  }

  private createRoutinePrompt(program: Program): string {
    return `Create a daily routine for program: ${program.name}. Return JSON array with title, duration, and description for each routine item.`;
  }

  // Response parsing methods (simplified versions)
  private parseVariationResponse(response: string): MealVariation {
    try {
      const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      const parsed = JSON.parse(cleanedResponse);
      return {
        title: parsed.title || 'Untitled Variation',
        description: parsed.description,
        type: parsed.type,
        cookingTime: parsed.cookingTime,
        cookingMethod: parsed.cookingMethod,
        ingredients: parsed.ingredients || {},
        instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
        nutritionalInfo: parsed.nutritionalInfo,
        categories: Array.isArray(parsed.categories) ? parsed.categories : [],
        serveQty: parsed.serveQty,
        suggestions: parsed.suggestions
      };
    } catch (error) {
      console.error('Error parsing variation response:', error);
      throw new Error('Failed to parse variation response');
    }
  }

  private parseCookingMethodResponse(response: string): EnhancedCookingMethod {
    try {
      const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      const parsed = JSON.parse(cleanedResponse);
      return {
        description: parsed.description || 'No description available',
        howItWorks: parsed.howItWorks || 'No details available',
        equipment: Array.isArray(parsed.equipment) ? parsed.equipment : [],
        bestFor: Array.isArray(parsed.bestFor) ? parsed.bestFor : [],
        heatType: parsed.heatType || 'Unknown heat type'
      };
    } catch (error) {
      console.error('Error parsing cooking method response:', error);
      throw new Error('Failed to parse cooking method response');
    }
  }

  private parseDietCategoryResponse(response: string): EnhancedDietCategory {
    try {
      const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      const parsed = JSON.parse(cleanedResponse);
      return {
        description: parsed.description || 'No description available',
        kidsFriendly: typeof parsed.kidsFriendly === 'boolean' ? parsed.kidsFriendly : false
      };
    } catch (error) {
      console.error('Error parsing diet category response:', error);
      throw new Error('Failed to parse diet category response');
    }
  }

  private parseGeminiResponse(response: string): EnhancedMealData {
    try {
      const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      const parsed = JSON.parse(cleanedResponse);
      return {
        description: parsed.description,
        type: parsed.type,
        cookingTime: parsed.cookingTime,
        cookingMethod: parsed.cookingMethod,
        ingredients: parsed.ingredients || {},
        instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
        nutritionalInfo: parsed.nutritionalInfo,
        categories: Array.isArray(parsed.categories) ? parsed.categories : [],
        serveQty: parsed.serveQty,
        suggestions: parsed.suggestions
      };
    } catch (error) {
      console.error('Error parsing Gemini response:', error);
      throw new Error('Failed to parse Gemini response');
    }
  }

  private parseIngredientResponse(response: string): EnhancedIngredientData {
    try {
      const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      const parsed = JSON.parse(cleanedResponse);
      return {
        title: parsed.title,
        type: parsed.type,
        calories: parsed.calories,
        macros: parsed.macros,
        categories: Array.isArray(parsed.categories) ? parsed.categories : undefined,
        features: parsed.features,
        techniques: Array.isArray(parsed.techniques) ? parsed.techniques : undefined,
        storageOptions: parsed.storageOptions,
        isAntiInflammatory: parsed.isAntiInflammatory,
        alt: Array.isArray(parsed.alt) ? parsed.alt : undefined,
        image: parsed.image
      };
    } catch (error) {
      console.error('Error parsing ingredient response:', error);
      throw new Error('Failed to parse ingredient response');
    }
  }

  private parseProgramPortionDetailsResponse(response: string): { notAllowed: string[]; portionDetails: Record<string, PortionDetail> } {
    try {
      const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      const parsed = JSON.parse(cleanedResponse);
      return {
        notAllowed: Array.isArray(parsed.notAllowed) ? parsed.notAllowed : [],
        portionDetails: parsed.portionDetails || {}
      };
    } catch (error) {
      console.error('Error parsing program portion details response:', error);
      throw new Error('Failed to parse program portion details response');
    }
  }

  private parseProgramResponse(response: string): any {
    try {
      const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      const parsed = JSON.parse(cleanedResponse);
      return parsed;
    } catch (error) {
      console.error('Error parsing program response:', error);
      throw new Error('Failed to parse program response');
    }
  }

  private parseRoutineResponse(response: string): any[] {
    try {
      const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      const parsed = JSON.parse(cleanedResponse);
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.error('Error parsing routine response:', error);
      throw new Error('Failed to parse routine response');
    }
  }
}
