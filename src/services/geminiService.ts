import { Meal } from '../types/meal';
import { CookingMethod, DietCategory, Program, PortionDetail } from '../types/collections';
import { Ingredient } from '../types/ingredient';

interface EnhancedMealData {
  description?: string;
  type?: 'protein' | 'grain' | 'vegetable' | 'fruit';
  cookingTime?: string;
  cookingMethod?: string;
  ingredients?: Record<string, string>;
  instructions?: string[];
  nutritionalInfo?: {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  };
  categories?: string[];
  serveQty?: number;
  suggestions?: {
    improvements: string[];
    alternatives: string[];
    additions: string[];
  };
}

interface MealVariation {
  title: string;
  description?: string;
  type?: 'protein' | 'grain' | 'vegetable' | 'fruit';
  cookingTime?: string;
  cookingMethod?: string;
  ingredients?: Record<string, string>;
  instructions?: string[];
  nutritionalInfo?: {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  };
  categories?: string[];
  serveQty?: number;
  suggestions?: {
    improvements: string[];
    alternatives: string[];
    additions: string[];
  };
}

interface EnhancedCookingMethod {
  description: string;
  howItWorks: string;
  equipment: string[];
  bestFor: string[];
  heatType: string;
}

interface EnhancedDietCategory {
  description: string;
  kidsFriendly: boolean;
}

interface EnhancedIngredientData {
  title?: string;
  type?: 'protein' | 'vegetable' | 'fruit' | 'grain' | 'sweetener' | 'condiment' | 'pastry';
  calories?: number;
  macros?: {
    protein: string;
    carbs: string;
    fat: string;
  };
  categories?: string[];
  features?: {
    fiber: string;
    g_i: string;
    season: string;
    water: string;
    rainbow: string;
  };
  techniques?: string[];
  storageOptions?: {
    countertop: string;
    fridge: string;
    freezer: string;
  };
  isAntiInflammatory?: boolean;
  alt?: string[];
  image?: string;
}

export class GeminiService {
  private apiKey: string;
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';

  constructor() {
    this.apiKey = process.env.VITE_GEMINI_API_KEY || '';
    if (!this.apiKey) {
      throw new Error('VITE_GEMINI_API_KEY environment variable is required');
    }
  }

  /**
   * Transforms a duplicate meal into a unique variation
   */
  async createMealVariation(originalMeal: Partial<Meal>, existingTitles: string[]): Promise<MealVariation> {
    const prompt = this.createVariationPrompt(originalMeal, existingTitles);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseVariationResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for variation:', error);
      throw error;
    }
  }

  /**
   * Enhances cooking method details using Gemini AI
   */
  async enhanceCookingMethod(cookingMethod: Partial<CookingMethod>): Promise<EnhancedCookingMethod> {
    const prompt = this.createCookingMethodPrompt(cookingMethod);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseCookingMethodResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for cooking method:', error);
      throw error;
    }
  }

  /**
   * Enhances diet category details using Gemini AI
   */
  async enhanceDietCategory(category: Partial<DietCategory>): Promise<EnhancedDietCategory> {
    const prompt = this.createDietCategoryPrompt(category);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseDietCategoryResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for diet category:', error);
      throw error;
    }
  }

  /**
   * Enhances meal data using Gemini AI
   */
  async enhanceMealDetails(meal: Partial<Meal>): Promise<EnhancedMealData> {
    const prompt = this.createEnhancementPrompt(meal);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseGeminiResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API:', error);
      throw error;
    }
  }

  /**
   * Enhances ingredient with complete details using Gemini AI
   */
  async enhanceIngredientDetails(ingredient: Partial<Ingredient>): Promise<EnhancedIngredientData> {
    const prompt = this.createIngredientEnhancementPrompt(ingredient);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseIngredientResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for ingredient enhancement (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback response for ingredient: ${ingredient.title}`);
          return {
            title: ingredient.title || 'Unknown Ingredient',
            type: 'vegetable', // Default to vegetable as a safe fallback
            calories: 0,
            macros: { protein: '0', carbs: '0', fat: '0' },
            categories: ['fallback'],
            features: {
              fiber: '0',
              g_i: '0',
              season: 'unknown',
              water: '0',
              rainbow: 'unknown'
            },
            techniques: ['fallback'],
            storageOptions: {
              countertop: 'unknown',
              fridge: 'unknown',
              freezer: 'unknown'
            },
            isAntiInflammatory: false,
            alt: ['fallback'],
            image: ''
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to enhance ingredient after all retries');
  }

  /**
   * Creates an ingredient variation using Gemini AI
   */
  async createIngredientVariation(originalIngredient: Partial<Ingredient>, existingTitles: string[]): Promise<EnhancedIngredientData> {
    const prompt = this.createIngredientVariationPrompt(originalIngredient, existingTitles);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseIngredientResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for ingredient variation (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback variation for ingredient: ${originalIngredient.title}`);
          return {
            title: `${originalIngredient.title} Variation`,
            type: originalIngredient.type || 'vegetable',
            calories: originalIngredient.calories || 0,
            macros: originalIngredient.macros || { protein: '0', carbs: '0', fat: '0' },
            categories: originalIngredient.categories || ['fallback'],
            features: originalIngredient.features || {
              fiber: '0',
              g_i: '0',
              season: 'unknown',
              water: '0',
              rainbow: 'unknown'
            },
            techniques: originalIngredient.techniques || ['fallback'],
            storageOptions: originalIngredient.storageOptions || {
              countertop: 'unknown',
              fridge: 'unknown',
              freezer: 'unknown'
            },
            isAntiInflammatory: originalIngredient.isAntiInflammatory || false,
            alt: originalIngredient.alt || ['fallback'],
            image: originalIngredient.image || ''
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to create ingredient variation after all retries');
  }

  /**
   * Generates a new unique ingredient of a specific type
   */
  async generateNewIngredient(type: 'protein' | 'vegetable' | 'fruit' | 'grain', existingTitles: string[]): Promise<EnhancedIngredientData> {
    const prompt = this.createNewIngredientGenerationPrompt(type, existingTitles);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseIngredientResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for new ingredient generation (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback new ingredient for type: ${type}`);
          return {
            title: `New ${type}`,
            type: type,
            calories: 0,
            macros: { protein: '0', carbs: '0', fat: '0' },
            categories: ['fallback'],
            features: {
              fiber: '0',
              g_i: '0',
              season: 'unknown',
              water: '0',
              rainbow: 'unknown'
            },
            techniques: ['fallback'],
            storageOptions: {
              countertop: 'unknown',
              fridge: 'unknown',
              freezer: 'unknown'
            },
            isAntiInflammatory: false,
            alt: ['fallback'],
            image: ''
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to generate new ingredient after all retries');
  }

  /**
   * Enhances an existing program with comprehensive details using Gemini AI
   */
  async enhanceExistingProgram(program: any): Promise<any> {
    const prompt = this.createExistingProgramEnhancementPrompt(program);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseProgramResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for existing program enhancement (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback response for existing program: ${program.name}`);
          return {
            name: program.name,
            type: program.type || 'Balanced',
            description: 'Fallback description',
            duration: '4 weeks',
            goals: ['Fallback goal'],
            mealPlan: {
              overview: 'Fallback meal plan',
              dailyStructure: 'Fallback structure',
              keyPrinciples: ['Fallback principle'],
              sampleMeals: ['Fallback meal']
            },
            fitnessProgram: {
              overview: 'Fallback fitness program',
              workoutTypes: ['Fallback workout'],
              frequency: '3 times per week',
              duration: '30 minutes',
              exercises: ['Fallback exercise']
            },
            guidelines: ['Fallback guideline'],
            benefits: ['Fallback benefit'],
            difficulty: 'Beginner',
            tips: ['Fallback tip'],
            notAllowed: ['snack'],
            portionDetails: {
              'fallback': {
                palmPercentage: 'unknown',
                spatulaSize: 'unknown',
                examples: ['fallback'],
                calories: '0'
              }
            }
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to enhance existing program after all retries');
  }

  /**
   * Enhances a program with portion details and not-allowed foods using Gemini AI
   */
  async enhanceProgramPortionDetails(program: any): Promise<{ notAllowed: string[]; portionDetails: Record<string, PortionDetail> }> {
    const prompt = this.createProgramPortionDetailsPrompt(program);
    const maxRetries = 3;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }]
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!generatedText) {
          throw new Error('No response generated by Gemini');
        }

        return this.parseProgramPortionDetailsResponse(generatedText);
      } catch (error) {
        console.error(`Error calling Gemini API for program portion details (attempt ${attempt}/${maxRetries}):`, error);
        
        if (attempt === maxRetries) {
          // On final attempt, try to create a basic fallback response
          console.log(`Creating fallback response for program: ${program.name}`);
          return {
            notAllowed: ['snack'], // Use valid option instead of 'fallback'
            portionDetails: {
              'fallback': {
                palmPercentage: 'unknown',
                spatulaSize: 'unknown',
                examples: ['fallback'],
                calories: '0'
              }
            }
          };
        }
        
        // Wait before retrying (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
    
    // This should never be reached, but just in case
    throw new Error('Failed to enhance program portion details after all retries');
  }

  /**
   * Creates comprehensive program details using Gemini AI
   */
  async createProgram(programType: Program['type']): Promise<any> {
    const prompt = this.createProgramPrompt(programType);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseProgramResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for program creation:', error);
      throw error;
    }
  }

  /**
   * Creates a daily routine for an existing program using Gemini AI
   */
  async createProgramRoutine(program: Program): Promise<any[]> {
    const prompt = this.createRoutinePrompt(program);
    
    try {
      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No response generated by Gemini');
      }

      return this.parseRoutineResponse(generatedText);
    } catch (error) {
      console.error('Error calling Gemini API for routine creation:', error);
      throw error;
    }
  }

  // Prompt creation methods (simplified versions)
  private createVariationPrompt(meal: Partial<Meal>, existingTitles: string[]): string {
    return `Create a unique variation of this meal: ${meal.title}. Existing titles to avoid: ${existingTitles.join(', ')}. Return JSON with title, description, type, cookingTime, cookingMethod, ingredients, instructions, nutritionalInfo, categories, serveQty, and suggestions.`;
  }

  private createCookingMethodPrompt(cookingMethod: Partial<CookingMethod>): string {
    return `Enhance this cooking method: ${cookingMethod.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "howItWorks": "string",
  "equipment": ["string"],
  "bestFor": ["string"],
  "heatType": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createDietCategoryPrompt(category: Partial<DietCategory>): string {
    return `Enhance this diet category: ${category.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "kidsFriendly": boolean
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createEnhancementPrompt(meal: Partial<Meal>): string {
    return `Enhance this meal: ${meal.title}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "type": "string",
  "cookingTime": "string",
  "cookingMethod": "string",
  "ingredients": {},
  "instructions": ["string"],
  "nutritionalInfo": {},
  "categories": ["string"],
  "serveQty": "string",
  "suggestions": ["string"]
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createIngredientVariationPrompt(ingredient: Partial<Ingredient>, existingTitles: string[]): string {
    return `Create a unique variation of this ingredient: ${ingredient.title}. Existing titles to avoid: ${existingTitles.join(', ')}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "string", 
  "calories": number,
  "macros": {
    "protein": "string",
    "carbs": "string",
    "fat": "string"
  },
  "categories": ["string"],
  "features": {
    "fiber": "string",
    "g_i": "string",
    "season": "string",
    "water": "string",
    "rainbow": "string"
  },
  "techniques": ["string"],
  "storageOptions": {
    "countertop": "string",
    "fridge": "string",
    "freezer": "string"
  },
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createNewIngredientGenerationPrompt(type: 'protein' | 'vegetable' | 'fruit' | 'grain', existingTitles: string[]): string {
    return `Generate a new unique ${type} ingredient. Existing titles to avoid: ${existingTitles.join(', ')}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "${type}", 
  "calories": number,
  "macros": {
    "protein": "string",
    "carbs": "string",
    "fat": "string"
  },
  "categories": ["string"],
  "features": {
    "fiber": "string",
    "g_i": "string",
    "season": "string",
    "water": "string",
    "rainbow": "string"
  },
  "techniques": ["string"],
  "storageOptions": {
    "countertop": "string",
    "fridge": "string",
    "freezer": "string"
  },
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createIngredientEnhancementPrompt(ingredient: Partial<Ingredient>): string {
    return `Enhance this ingredient: ${ingredient.title}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "string", 
  "calories": number,
  "macros": {
    "protein": number,
    "carbs": number,
    "fat": number,
    "fiber": number
  },
  "categories": ["string"],
  "features": ["string"],
  "techniques": ["string"],
  "storageOptions": ["string"],
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createExistingProgramEnhancementPrompt(program: Program): string {
    return `Enhance this existing program: ${program.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "name": "${program.name}",
  "type": "${program.type || 'Balanced'}",
  "description": "string",
  "duration": "string",
  "goals": ["string"],
  "mealPlan": {
    "overview": "string",
    "dailyStructure": "string",
    "keyPrinciples": ["string"],
    "sampleMeals": ["string"]
  },
  "fitnessProgram": {
    "overview": "string",
    "workoutTypes": ["string"],
    "frequency": "string",
    "duration": "string",
    "exercises": ["string"]
  },
  "guidelines": ["string"],
  "benefits": ["string"],
  "difficulty": "Beginner|Intermediate|Advanced",
  "tips": ["string"],
  "notAllowed": ["string"],
  "portionDetails": {
    "foodCategory": {
      "palmPercentage": "string",
      "spatulaSize": "string",
      "examples": ["string"],
      "calories": "string"
    }
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "notAllowed" array can ONLY contain these 4 options: "snack", "fruit", "dessert", "alcohol"
3. Choose the most appropriate option(s) based on the program's focus and goals.
4. The response should be valid JSON that can be parsed directly.
5. Keep the existing program name and type, but enhance all other fields.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createProgramPortionDetailsPrompt(program: Program): string {
    return `Enhance this program: ${program.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "notAllowed": ["string"],
  "portionDetails": {
    "foodCategory": {
      "palmPercentage": "string",
      "spatulaSize": "string",
      "examples": ["string"],
      "calories": "string"
    }
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "notAllowed" array can ONLY contain these 4 options: "snack", "fruit", "dessert", "alcohol"
3. Choose the most appropriate option(s) based on the program's focus and goals.
4. The response should be valid JSON that can be parsed directly.

Example structure for portionDetails:
- "protein": {"palmPercentage": "1 palm", "spatulaSize": "1 spatula", "examples": ["chicken", "fish"], "calories": "300"}
- "vegetables": {"palmPercentage": "2 palms", "spatulaSize": "2 spatulas", "examples": ["broccoli", "spinach"], "calories": "100"}
- "fruits": {"palmPercentage": "1 palm", "spatulaSize": "1 spatula", "examples": ["apple", "banana"], "calories": "80"}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createProgramPrompt(programType: Program['type']): string {
    return `Create a comprehensive program for type: ${programType}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "name": "string",
  "description": "string",
  "duration": "string",
  "goals": ["string"],
  "mealPlan": "string",
  "fitnessProgram": "string",
  "guidelines": ["string"],
  "benefits": ["string"],
  "difficulty": "string",
  "tips": ["string"],
  "notAllowed": ["string"],
  "portionDetails": {
    "foodCategory": {
      "palmPercentage": "string",
      "spatulaSize": "string",
      "examples": ["string"],
      "calories": "string"
    }
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "notAllowed" array can ONLY contain these 4 options: "snack", "fruit", "dessert", "alcohol"
3. Choose the most appropriate option(s) based on the program type and goals.
4. The response should be valid JSON that can be parsed directly.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  private createRoutinePrompt(program: Program): string {
    return `Create a daily routine for program: ${program.name}. 

Return a valid JSON array with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

[
  {
    "title": "string",
    "duration": "string",
    "description": "string"
  }
]

IMPORTANT: Return ONLY the JSON array. Do not include any code examples, explanations, or other text. The response should be valid JSON that can be parsed directly.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
  }

  // Response parsing methods (simplified versions)
  private parseVariationResponse(response: string): MealVariation {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        title: parsed.title || 'Untitled Variation',
        description: parsed.description,
        type: parsed.type,
        cookingTime: parsed.cookingTime,
        cookingMethod: parsed.cookingMethod,
        ingredients: parsed.ingredients || {},
        instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
        nutritionalInfo: parsed.nutritionalInfo,
        categories: Array.isArray(parsed.categories) ? parsed.categories : [],
        serveQty: parsed.serveQty,
        suggestions: parsed.suggestions
      };
    } catch (error) {
      console.error('Error parsing variation response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse variation response');
    }
  }

  private parseCookingMethodResponse(response: string): EnhancedCookingMethod {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        description: parsed.description || 'No description available',
        howItWorks: parsed.howItWorks || 'No details available',
        equipment: Array.isArray(parsed.equipment) ? parsed.equipment : [],
        bestFor: Array.isArray(parsed.bestFor) ? parsed.bestFor : [],
        heatType: parsed.heatType || 'Unknown heat type'
      };
    } catch (error) {
      console.error('Error parsing cooking method response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse cooking method response');
    }
  }

  private parseDietCategoryResponse(response: string): EnhancedDietCategory {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        description: parsed.description || 'No description available',
        kidsFriendly: typeof parsed.kidsFriendly === 'boolean' ? parsed.kidsFriendly : false
      };
    } catch (error) {
      console.error('Error parsing diet category response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse diet category response');
    }
  }

  private parseGeminiResponse(response: string): EnhancedMealData {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        description: parsed.description,
        type: parsed.type,
        cookingTime: parsed.cookingTime,
        cookingMethod: parsed.cookingMethod,
        ingredients: parsed.ingredients || {},
        instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
        nutritionalInfo: parsed.nutritionalInfo,
        categories: Array.isArray(parsed.categories) ? parsed.categories : [],
        serveQty: parsed.serveQty,
        suggestions: parsed.suggestions
      };
    } catch (error) {
      console.error('Error parsing Gemini response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse Gemini response');
    }
  }

  private parseIngredientResponse(response: string): EnhancedIngredientData {
    try {
      console.log('Raw Gemini response:', response.substring(0, 500) + '...');
      
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      console.log('Cleaned JSON:', cleanedResponse.substring(0, 500) + '...');
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        title: parsed.title,
        type: parsed.type,
        calories: parsed.calories,
        macros: parsed.macros,
        categories: Array.isArray(parsed.categories) ? parsed.categories : undefined,
        features: parsed.features,
        techniques: Array.isArray(parsed.techniques) ? parsed.techniques : undefined,
        storageOptions: parsed.storageOptions,
        isAntiInflammatory: parsed.isAntiInflammatory,
        alt: Array.isArray(parsed.alt) ? parsed.alt : undefined,
        image: parsed.image
      };
    } catch (error) {
      console.error('Error parsing ingredient response:', error);
      console.error('Raw response:', response);
      
      // Try to extract the ingredient title from the response for fallback
      const titleMatch = response.match(/ingredient:\s*([^\n,]+)/i) || 
                        response.match(/title["\s]*:\s*["']?([^"'\n,]+)/i) ||
                        response.match(/enhance.*?:\s*([^\n,]+)/i);
      
      const ingredientTitle = titleMatch ? titleMatch[1].trim() : 'Unknown Ingredient';
      
      console.log(`Creating fallback response for ingredient: ${ingredientTitle}`);
      
      // Return a basic fallback response
      return {
        title: ingredientTitle,
        type: 'vegetable', // Default to vegetable as a safe fallback
        calories: 0,
        macros: { protein: '0', carbs: '0', fat: '0' },
        categories: ['fallback'],
        features: {
          fiber: '0',
          g_i: '0',
          season: 'unknown',
          water: '0',
          rainbow: 'unknown'
        },
        techniques: ['fallback'],
        storageOptions: {
          countertop: 'unknown',
          fridge: 'unknown',
          freezer: 'unknown'
        },
        isAntiInflammatory: false,
        alt: ['fallback'],
        image: ''
      };
    }
  }

  /**
   * Fixes common JSON formatting issues that AI models often produce
   */
  private fixCommonJsonIssues(jsonString: string): string {
    // Remove any leading/trailing text that's not JSON
    let cleaned = jsonString.trim();
    
    // Fix unquoted property names (more comprehensive)
    cleaned = cleaned.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
    
    // Fix single quotes to double quotes
    cleaned = cleaned.replace(/'/g, '"');
    
    // Fix trailing commas
    cleaned = cleaned.replace(/,(\s*[}\]])/g, '$1');
    
    // Fix boolean values that might be strings
    cleaned = cleaned.replace(/"true"/g, 'true');
    cleaned = cleaned.replace(/"false"/g, 'false');
    
    // Fix numeric values that might be strings
    cleaned = cleaned.replace(/"(\d+(?:\.\d+)?)"/g, '$1');
    
    // Fix escaped quotes within strings
    cleaned = cleaned.replace(/\\"/g, '"');
    
    // Fix newlines and tabs within strings
    cleaned = cleaned.replace(/\\n/g, ' ');
    cleaned = cleaned.replace(/\\t/g, ' ');
    
    // Fix multiple spaces
    cleaned = cleaned.replace(/\s+/g, ' ');
    
    // Fix missing closing braces/brackets
    const openBraces = (cleaned.match(/\{/g) || []).length;
    const closeBraces = (cleaned.match(/\}/g) || []).length;
    const openBrackets = (cleaned.match(/\[/g) || []).length;
    const closeBrackets = (cleaned.match(/\]/g) || []).length;
    
    // Add missing closing braces
    for (let i = 0; i < openBraces - closeBraces; i++) {
      cleaned += '}';
    }
    
    // Add missing closing brackets
    for (let i = 0; i < openBrackets - closeBrackets; i++) {
      cleaned += ']';
    }
    
    return cleaned;
  }

  private parseProgramPortionDetailsResponse(response: string): { notAllowed: string[]; portionDetails: Record<string, PortionDetail> } {
    try {
      console.log('Raw program response:', response.substring(0, 500) + '...');
      
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // First, try to parse the JSON as-is to see if it's already valid
      try {
        const parsed = JSON.parse(cleanedResponse);
        console.log('JSON parsed successfully without cleaning');
        return {
          notAllowed: Array.isArray(parsed.notAllowed) ? parsed.notAllowed : [],
          portionDetails: parsed.portionDetails || {}
        };
      } catch (initialError) {
        console.log('Initial JSON parsing failed, attempting to fix...');
      }
      
      // If initial parsing failed, try to fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      console.log('Cleaned program JSON:', cleanedResponse.substring(0, 500) + '...');
      
      const parsed = JSON.parse(cleanedResponse);
      return {
        notAllowed: Array.isArray(parsed.notAllowed) ? parsed.notAllowed : [],
        portionDetails: parsed.portionDetails || {}
      };
    } catch (error) {
      console.error('Error parsing program portion details response:', error);
      console.error('Raw response:', response);
      
      // Try to extract program name from the response for fallback
      const programMatch = response.match(/program.*?:\s*["']?([^"'\n,]+)/i) || 
                          response.match(/enhance.*?:\s*["']?([^"'\n,]+)/i);
      
      const programName = programMatch ? programMatch[1].trim() : 'Unknown Program';
      
      console.log(`Creating fallback response for program: ${programName}`);
      
      // Return a basic fallback response
      return {
        notAllowed: ['snack'], // Use valid option instead of 'fallback'
        portionDetails: {
          'fallback': {
            palmPercentage: 'unknown',
            spatulaSize: 'unknown',
            examples: ['fallback'],
            calories: '0'
          }
        }
      };
    }
  }

  private parseProgramResponse(response: string): any {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return parsed;
    } catch (error) {
      console.error('Error parsing program response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse program response');
    }
  }

  private parseRoutineResponse(response: string): any[] {
    try {
      // Clean the response more thoroughly
      let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
      
      // Try to extract JSON from the response if it's wrapped in other text
      const jsonMatch = cleanedResponse.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        cleanedResponse = jsonMatch[0];
      }
      
      // Fix common JSON issues
      cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
      
      const parsed = JSON.parse(cleanedResponse);
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.error('Error parsing routine response:', error);
      console.error('Raw response:', response);
      throw new Error('Failed to parse routine response');
    }
  }
}
