"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeminiService = void 0;
class GeminiService {
    constructor() {
        this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';
        this.apiKey = process.env.VITE_GEMINI_API_KEY || '';
        if (!this.apiKey) {
            throw new Error('VITE_GEMINI_API_KEY environment variable is required');
        }
    }
    /**
     * Transforms a duplicate meal into a unique variation
     */
    async createMealVariation(originalMeal, existingTitles) {
        const prompt = this.createVariationPrompt(originalMeal, existingTitles);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseVariationResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for variation:', error);
            throw error;
        }
    }
    /**
     * Enhances cooking method details using Gemini AI
     */
    async enhanceCookingMethod(cookingMethod) {
        const prompt = this.createCookingMethodPrompt(cookingMethod);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseCookingMethodResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for cooking method:', error);
            throw error;
        }
    }
    /**
     * Enhances diet category details using Gemini AI
     */
    async enhanceDietCategory(category) {
        const prompt = this.createDietCategoryPrompt(category);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseDietCategoryResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for diet category:', error);
            throw error;
        }
    }
    /**
     * Enhances meal data using Gemini AI
     */
    async enhanceMealDetails(meal) {
        const prompt = this.createEnhancementPrompt(meal);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseGeminiResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API:', error);
            throw error;
        }
    }
    /**
     * Enhances ingredient with complete details using Gemini AI
     */
    async enhanceIngredientDetails(ingredient) {
        const prompt = this.createIngredientEnhancementPrompt(ingredient);
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                                parts: [{
                                        text: prompt
                                    }]
                            }]
                    })
                });
                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!generatedText) {
                    throw new Error('No response generated by Gemini');
                }
                return this.parseIngredientResponse(generatedText);
            }
            catch (error) {
                console.error(`Error calling Gemini API for ingredient enhancement (attempt ${attempt}/${maxRetries}):`, error);
                if (attempt === maxRetries) {
                    // On final attempt, try to create a basic fallback response
                    console.log(`Creating fallback response for ingredient: ${ingredient.title}`);
                    return {
                        title: ingredient.title || 'Unknown Ingredient',
                        type: 'vegetable', // Default to vegetable as a safe fallback
                        calories: 0,
                        macros: { protein: '0', carbs: '0', fat: '0' },
                        categories: ['fallback'],
                        features: {
                            fiber: '0',
                            g_i: '0',
                            season: 'unknown',
                            water: '0',
                            rainbow: 'unknown'
                        },
                        techniques: ['fallback'],
                        storageOptions: {
                            countertop: 'unknown',
                            fridge: 'unknown',
                            freezer: 'unknown'
                        },
                        isAntiInflammatory: false,
                        alt: ['fallback'],
                        image: ''
                    };
                }
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            }
        }
        // This should never be reached, but just in case
        throw new Error('Failed to enhance ingredient after all retries');
    }
    /**
     * Creates an ingredient variation using Gemini AI
     */
    async createIngredientVariation(originalIngredient, existingTitles) {
        const prompt = this.createIngredientVariationPrompt(originalIngredient, existingTitles);
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                                parts: [{
                                        text: prompt
                                    }]
                            }]
                    })
                });
                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!generatedText) {
                    throw new Error('No response generated by Gemini');
                }
                return this.parseIngredientResponse(generatedText);
            }
            catch (error) {
                console.error(`Error calling Gemini API for ingredient variation (attempt ${attempt}/${maxRetries}):`, error);
                if (attempt === maxRetries) {
                    // On final attempt, try to create a basic fallback response
                    console.log(`Creating fallback variation for ingredient: ${originalIngredient.title}`);
                    return {
                        title: `${originalIngredient.title} Variation`,
                        type: originalIngredient.type || 'vegetable',
                        calories: originalIngredient.calories || 0,
                        macros: originalIngredient.macros || { protein: '0', carbs: '0', fat: '0' },
                        categories: originalIngredient.categories || ['fallback'],
                        features: originalIngredient.features || {
                            fiber: '0',
                            g_i: '0',
                            season: 'unknown',
                            water: '0',
                            rainbow: 'unknown'
                        },
                        techniques: originalIngredient.techniques || ['fallback'],
                        storageOptions: originalIngredient.storageOptions || {
                            countertop: 'unknown',
                            fridge: 'unknown',
                            freezer: 'unknown'
                        },
                        isAntiInflammatory: originalIngredient.isAntiInflammatory || false,
                        alt: originalIngredient.alt || ['fallback'],
                        image: originalIngredient.image || ''
                    };
                }
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            }
        }
        // This should never be reached, but just in case
        throw new Error('Failed to create ingredient variation after all retries');
    }
    /**
     * Generates a new unique ingredient of a specific type
     */
    async generateNewIngredient(type, existingTitles) {
        const prompt = this.createNewIngredientGenerationPrompt(type, existingTitles);
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                                parts: [{
                                        text: prompt
                                    }]
                            }]
                    })
                });
                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!generatedText) {
                    throw new Error('No response generated by Gemini');
                }
                return this.parseIngredientResponse(generatedText);
            }
            catch (error) {
                console.error(`Error calling Gemini API for new ingredient generation (attempt ${attempt}/${maxRetries}):`, error);
                if (attempt === maxRetries) {
                    // On final attempt, try to create a basic fallback response
                    console.log(`Creating fallback new ingredient for type: ${type}`);
                    return {
                        title: `New ${type}`,
                        type: type,
                        calories: 0,
                        macros: { protein: '0', carbs: '0', fat: '0' },
                        categories: ['fallback'],
                        features: {
                            fiber: '0',
                            g_i: '0',
                            season: 'unknown',
                            water: '0',
                            rainbow: 'unknown'
                        },
                        techniques: ['fallback'],
                        storageOptions: {
                            countertop: 'unknown',
                            fridge: 'unknown',
                            freezer: 'unknown'
                        },
                        isAntiInflammatory: false,
                        alt: ['fallback'],
                        image: ''
                    };
                }
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            }
        }
        // This should never be reached, but just in case
        throw new Error('Failed to generate new ingredient after all retries');
    }
    /**
     * Enhances a program with portion details and not-allowed foods using Gemini AI
     */
    async enhanceProgramPortionDetails(program) {
        const prompt = this.createProgramPortionDetailsPrompt(program);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseProgramPortionDetailsResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for program portion details:', error);
            throw error;
        }
    }
    /**
     * Creates comprehensive program details using Gemini AI
     */
    async createProgram(programType) {
        const prompt = this.createProgramPrompt(programType);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseProgramResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for program creation:', error);
            throw error;
        }
    }
    /**
     * Creates a daily routine for an existing program using Gemini AI
     */
    async createProgramRoutine(program) {
        const prompt = this.createRoutinePrompt(program);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseRoutineResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for routine creation:', error);
            throw error;
        }
    }
    // Prompt creation methods (simplified versions)
    createVariationPrompt(meal, existingTitles) {
        return `Create a unique variation of this meal: ${meal.title}. Existing titles to avoid: ${existingTitles.join(', ')}. Return JSON with title, description, type, cookingTime, cookingMethod, ingredients, instructions, nutritionalInfo, categories, serveQty, and suggestions.`;
    }
    createCookingMethodPrompt(cookingMethod) {
        return `Enhance this cooking method: ${cookingMethod.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "howItWorks": "string",
  "equipment": ["string"],
  "bestFor": ["string"],
  "heatType": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createDietCategoryPrompt(category) {
        return `Enhance this diet category: ${category.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "kidsFriendly": boolean
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createEnhancementPrompt(meal) {
        return `Enhance this meal: ${meal.title}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "type": "string",
  "cookingTime": "string",
  "cookingMethod": "string",
  "ingredients": {},
  "instructions": ["string"],
  "nutritionalInfo": {},
  "categories": ["string"],
  "serveQty": "string",
  "suggestions": ["string"]
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createIngredientVariationPrompt(ingredient, existingTitles) {
        return `Create a unique variation of this ingredient: ${ingredient.title}. Existing titles to avoid: ${existingTitles.join(', ')}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "string", 
  "calories": number,
  "macros": {
    "protein": "string",
    "carbs": "string",
    "fat": "string"
  },
  "categories": ["string"],
  "features": {
    "fiber": "string",
    "g_i": "string",
    "season": "string",
    "water": "string",
    "rainbow": "string"
  },
  "techniques": ["string"],
  "storageOptions": {
    "countertop": "string",
    "fridge": "string",
    "freezer": "string"
  },
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createNewIngredientGenerationPrompt(type, existingTitles) {
        return `Generate a new unique ${type} ingredient. Existing titles to avoid: ${existingTitles.join(', ')}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "${type}", 
  "calories": number,
  "macros": {
    "protein": "string",
    "carbs": "string",
    "fat": "string"
  },
  "categories": ["string"],
  "features": {
    "fiber": "string",
    "g_i": "string",
    "season": "string",
    "water": "string",
    "rainbow": "string"
  },
  "techniques": ["string"],
  "storageOptions": {
    "countertop": "string",
    "fridge": "string",
    "freezer": "string"
  },
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createIngredientEnhancementPrompt(ingredient) {
        return `Enhance this ingredient: ${ingredient.title}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "string", 
  "calories": number,
  "macros": {
    "protein": number,
    "carbs": number,
    "fat": number,
    "fiber": number
  },
  "categories": ["string"],
  "features": ["string"],
  "techniques": ["string"],
  "storageOptions": ["string"],
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createProgramPortionDetailsPrompt(program) {
        return `Enhance this program: ${program.name}. Return JSON with notAllowed array and portionDetails object.`;
    }
    createProgramPrompt(programType) {
        return `Create a comprehensive program for type: ${programType}. Return JSON with name, description, duration, goals, mealPlan, fitnessProgram, guidelines, benefits, difficulty, tips, notAllowed, and portionDetails.`;
    }
    createRoutinePrompt(program) {
        return `Create a daily routine for program: ${program.name}. Return JSON array with title, duration, and description for each routine item.`;
    }
    // Response parsing methods (simplified versions)
    parseVariationResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return {
                title: parsed.title || 'Untitled Variation',
                description: parsed.description,
                type: parsed.type,
                cookingTime: parsed.cookingTime,
                cookingMethod: parsed.cookingMethod,
                ingredients: parsed.ingredients || {},
                instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
                nutritionalInfo: parsed.nutritionalInfo,
                categories: Array.isArray(parsed.categories) ? parsed.categories : [],
                serveQty: parsed.serveQty,
                suggestions: parsed.suggestions
            };
        }
        catch (error) {
            console.error('Error parsing variation response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse variation response');
        }
    }
    parseCookingMethodResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return {
                description: parsed.description || 'No description available',
                howItWorks: parsed.howItWorks || 'No details available',
                equipment: Array.isArray(parsed.equipment) ? parsed.equipment : [],
                bestFor: Array.isArray(parsed.bestFor) ? parsed.bestFor : [],
                heatType: parsed.heatType || 'Unknown heat type'
            };
        }
        catch (error) {
            console.error('Error parsing cooking method response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse cooking method response');
        }
    }
    parseDietCategoryResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return {
                description: parsed.description || 'No description available',
                kidsFriendly: typeof parsed.kidsFriendly === 'boolean' ? parsed.kidsFriendly : false
            };
        }
        catch (error) {
            console.error('Error parsing diet category response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse diet category response');
        }
    }
    parseGeminiResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return {
                description: parsed.description,
                type: parsed.type,
                cookingTime: parsed.cookingTime,
                cookingMethod: parsed.cookingMethod,
                ingredients: parsed.ingredients || {},
                instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
                nutritionalInfo: parsed.nutritionalInfo,
                categories: Array.isArray(parsed.categories) ? parsed.categories : [],
                serveQty: parsed.serveQty,
                suggestions: parsed.suggestions
            };
        }
        catch (error) {
            console.error('Error parsing Gemini response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse Gemini response');
        }
    }
    parseIngredientResponse(response) {
        try {
            console.log('Raw Gemini response:', response.substring(0, 500) + '...');
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            console.log('Cleaned JSON:', cleanedResponse.substring(0, 500) + '...');
            const parsed = JSON.parse(cleanedResponse);
            return {
                title: parsed.title,
                type: parsed.type,
                calories: parsed.calories,
                macros: parsed.macros,
                categories: Array.isArray(parsed.categories) ? parsed.categories : undefined,
                features: parsed.features,
                techniques: Array.isArray(parsed.techniques) ? parsed.techniques : undefined,
                storageOptions: parsed.storageOptions,
                isAntiInflammatory: parsed.isAntiInflammatory,
                alt: Array.isArray(parsed.alt) ? parsed.alt : undefined,
                image: parsed.image
            };
        }
        catch (error) {
            console.error('Error parsing ingredient response:', error);
            console.error('Raw response:', response);
            // Try to extract the ingredient title from the response for fallback
            const titleMatch = response.match(/ingredient:\s*([^\n,]+)/i) ||
                response.match(/title["\s]*:\s*["']?([^"'\n,]+)/i) ||
                response.match(/enhance.*?:\s*([^\n,]+)/i);
            const ingredientTitle = titleMatch ? titleMatch[1].trim() : 'Unknown Ingredient';
            console.log(`Creating fallback response for ingredient: ${ingredientTitle}`);
            // Return a basic fallback response
            return {
                title: ingredientTitle,
                type: 'vegetable', // Default to vegetable as a safe fallback
                calories: 0,
                macros: { protein: '0', carbs: '0', fat: '0' },
                categories: ['fallback'],
                features: {
                    fiber: '0',
                    g_i: '0',
                    season: 'unknown',
                    water: '0',
                    rainbow: 'unknown'
                },
                techniques: ['fallback'],
                storageOptions: {
                    countertop: 'unknown',
                    fridge: 'unknown',
                    freezer: 'unknown'
                },
                isAntiInflammatory: false,
                alt: ['fallback'],
                image: ''
            };
        }
    }
    /**
     * Fixes common JSON formatting issues that AI models often produce
     */
    fixCommonJsonIssues(jsonString) {
        // Remove any leading/trailing text that's not JSON
        let cleaned = jsonString.trim();
        // Fix unquoted property names (more comprehensive)
        cleaned = cleaned.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
        // Fix single quotes to double quotes
        cleaned = cleaned.replace(/'/g, '"');
        // Fix trailing commas
        cleaned = cleaned.replace(/,(\s*[}\]])/g, '$1');
        // Fix missing quotes around string values that contain special characters
        cleaned = cleaned.replace(/:\s*([^"][^,}\]]*[^"\s,}\]])/g, (match, value) => {
            // Only quote if it's not already quoted and contains special characters
            if (!value.includes('"') && (value.includes(' ') || value.includes('-') || value.includes('/') || value.includes('(') || value.includes(')') || value.includes('&'))) {
                return `: "${value.trim()}"`;
            }
            return match;
        });
        // Fix boolean values that might be strings
        cleaned = cleaned.replace(/"true"/g, 'true');
        cleaned = cleaned.replace(/"false"/g, 'false');
        // Fix numeric values that might be strings
        cleaned = cleaned.replace(/"(\d+(?:\.\d+)?)"/g, '$1');
        // Fix escaped quotes within strings
        cleaned = cleaned.replace(/\\"/g, '"');
        // Fix newlines and tabs within strings
        cleaned = cleaned.replace(/\\n/g, ' ');
        cleaned = cleaned.replace(/\\t/g, ' ');
        // Fix multiple spaces
        cleaned = cleaned.replace(/\s+/g, ' ');
        // Fix missing closing braces/brackets
        const openBraces = (cleaned.match(/\{/g) || []).length;
        const closeBraces = (cleaned.match(/\}/g) || []).length;
        const openBrackets = (cleaned.match(/\[/g) || []).length;
        const closeBrackets = (cleaned.match(/\]/g) || []).length;
        // Add missing closing braces
        for (let i = 0; i < openBraces - closeBraces; i++) {
            cleaned += '}';
        }
        // Add missing closing brackets
        for (let i = 0; i < openBrackets - closeBrackets; i++) {
            cleaned += ']';
        }
        // Fix common issues with nested objects and arrays
        cleaned = cleaned.replace(/:\s*\[([^\]]*)\]/g, (match, content) => {
            // Ensure array content is properly formatted
            const items = content.split(',').map((item) => item.trim());
            const formattedItems = items.map((item) => {
                if (item.startsWith('"') && item.endsWith('"')) {
                    return item; // Already quoted
                }
                else if (item.match(/^\d+$/)) {
                    return item; // Number
                }
                else if (item === 'true' || item === 'false') {
                    return item; // Boolean
                }
                else {
                    return `"${item}"`; // Quote strings
                }
            });
            return `: [${formattedItems.join(', ')}]`;
        });
        // Fix issues with object properties that might be missing quotes
        cleaned = cleaned.replace(/"([^"]+)"\s*:\s*([^,}\]]+)/g, (match, key, value) => {
            if (value.trim().startsWith('"') && value.trim().endsWith('"')) {
                return match; // Already properly quoted
            }
            else if (value.trim().match(/^(true|false|\d+(?:\.\d+)?)$/)) {
                return match; // Boolean or number
            }
            else {
                return `"${key}": "${value.trim()}"`;
            }
        });
        return cleaned;
    }
    parseProgramPortionDetailsResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return {
                notAllowed: Array.isArray(parsed.notAllowed) ? parsed.notAllowed : [],
                portionDetails: parsed.portionDetails || {}
            };
        }
        catch (error) {
            console.error('Error parsing program portion details response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse program portion details response');
        }
    }
    parseProgramResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return parsed;
        }
        catch (error) {
            console.error('Error parsing program response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse program response');
        }
    }
    parseRoutineResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return Array.isArray(parsed) ? parsed : [];
        }
        catch (error) {
            console.error('Error parsing routine response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse routine response');
        }
    }
}
exports.GeminiService = GeminiService;
