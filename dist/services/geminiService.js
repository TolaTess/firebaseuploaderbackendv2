"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeminiService = void 0;
class GeminiService {
    constructor() {
        this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';
        this.apiKey = process.env.VITE_GEMINI_API_KEY || '';
        if (!this.apiKey) {
            throw new Error('VITE_GEMINI_API_KEY environment variable is required');
        }
    }
    /**
     * Transforms a duplicate meal into a unique variation
     */
    async createMealVariation(originalMeal, existingTitles) {
        const prompt = this.createVariationPrompt(originalMeal, existingTitles);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseVariationResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for variation:', error);
            throw error;
        }
    }
    /**
     * Enhances cooking method details using Gemini AI
     */
    async enhanceCookingMethod(cookingMethod) {
        const prompt = this.createCookingMethodPrompt(cookingMethod);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseCookingMethodResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for cooking method:', error);
            throw error;
        }
    }
    /**
     * Enhances diet category details using Gemini AI
     */
    async enhanceDietCategory(category) {
        const prompt = this.createDietCategoryPrompt(category);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseDietCategoryResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for diet category:', error);
            throw error;
        }
    }
    /**
     * Enhances meal data using Gemini AI
     */
    async enhanceMealDetails(meal) {
        const prompt = this.createEnhancementPrompt(meal);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseGeminiResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API:', error);
            throw error;
        }
    }
    /**
     * Enhances ingredient with complete details using Gemini AI
     */
    async enhanceIngredientDetails(ingredient) {
        const prompt = this.createIngredientEnhancementPrompt(ingredient);
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                                parts: [{
                                        text: prompt
                                    }]
                            }]
                    })
                });
                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!generatedText) {
                    throw new Error('No response generated by Gemini');
                }
                return this.parseIngredientResponse(generatedText);
            }
            catch (error) {
                console.error(`Error calling Gemini API for ingredient enhancement (attempt ${attempt}/${maxRetries}):`, error);
                if (attempt === maxRetries) {
                    // On final attempt, try to create a basic fallback response
                    console.log(`Creating fallback response for ingredient: ${ingredient.title}`);
                    return {
                        title: ingredient.title || 'Unknown Ingredient',
                        type: 'vegetable', // Default to vegetable as a safe fallback
                        calories: 0,
                        macros: { protein: '0', carbs: '0', fat: '0' },
                        categories: ['fallback'],
                        features: {
                            fiber: '0',
                            g_i: '0',
                            season: 'unknown',
                            water: '0',
                            rainbow: 'unknown'
                        },
                        techniques: ['fallback'],
                        storageOptions: {
                            countertop: 'unknown',
                            fridge: 'unknown',
                            freezer: 'unknown'
                        },
                        isAntiInflammatory: false,
                        alt: ['fallback'],
                        image: ''
                    };
                }
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            }
        }
        // This should never be reached, but just in case
        throw new Error('Failed to enhance ingredient after all retries');
    }
    /**
     * Creates an ingredient variation using Gemini AI
     */
    async createIngredientVariation(originalIngredient, existingTitles) {
        const prompt = this.createIngredientVariationPrompt(originalIngredient, existingTitles);
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                                parts: [{
                                        text: prompt
                                    }]
                            }]
                    })
                });
                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!generatedText) {
                    throw new Error('No response generated by Gemini');
                }
                return this.parseIngredientResponse(generatedText);
            }
            catch (error) {
                console.error(`Error calling Gemini API for ingredient variation (attempt ${attempt}/${maxRetries}):`, error);
                if (attempt === maxRetries) {
                    // On final attempt, try to create a basic fallback response
                    console.log(`Creating fallback variation for ingredient: ${originalIngredient.title}`);
                    return {
                        title: `${originalIngredient.title} Variation`,
                        type: originalIngredient.type || 'vegetable',
                        calories: originalIngredient.calories || 0,
                        macros: originalIngredient.macros || { protein: '0', carbs: '0', fat: '0' },
                        categories: originalIngredient.categories || ['fallback'],
                        features: originalIngredient.features || {
                            fiber: '0',
                            g_i: '0',
                            season: 'unknown',
                            water: '0',
                            rainbow: 'unknown'
                        },
                        techniques: originalIngredient.techniques || ['fallback'],
                        storageOptions: originalIngredient.storageOptions || {
                            countertop: 'unknown',
                            fridge: 'unknown',
                            freezer: 'unknown'
                        },
                        isAntiInflammatory: originalIngredient.isAntiInflammatory || false,
                        alt: originalIngredient.alt || ['fallback'],
                        image: originalIngredient.image || ''
                    };
                }
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            }
        }
        // This should never be reached, but just in case
        throw new Error('Failed to create ingredient variation after all retries');
    }
    /**
     * Generates a new unique ingredient of a specific type
     */
    async generateNewIngredient(type, existingTitles) {
        const prompt = this.createNewIngredientGenerationPrompt(type, existingTitles);
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                                parts: [{
                                        text: prompt
                                    }]
                            }]
                    })
                });
                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!generatedText) {
                    throw new Error('No response generated by Gemini');
                }
                return this.parseIngredientResponse(generatedText);
            }
            catch (error) {
                console.error(`Error calling Gemini API for new ingredient generation (attempt ${attempt}/${maxRetries}):`, error);
                if (attempt === maxRetries) {
                    // On final attempt, try to create a basic fallback response
                    console.log(`Creating fallback new ingredient for type: ${type}`);
                    return {
                        title: `New ${type}`,
                        type: type,
                        calories: 0,
                        macros: { protein: '0', carbs: '0', fat: '0' },
                        categories: ['fallback'],
                        features: {
                            fiber: '0',
                            g_i: '0',
                            season: 'unknown',
                            water: '0',
                            rainbow: 'unknown'
                        },
                        techniques: ['fallback'],
                        storageOptions: {
                            countertop: 'unknown',
                            fridge: 'unknown',
                            freezer: 'unknown'
                        },
                        isAntiInflammatory: false,
                        alt: ['fallback'],
                        image: ''
                    };
                }
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            }
        }
        // This should never be reached, but just in case
        throw new Error('Failed to generate new ingredient after all retries');
    }
    /**
     * Enhances an existing program with comprehensive details using Gemini AI
     */
    async enhanceExistingProgram(program) {
        const prompt = this.createExistingProgramEnhancementPrompt(program);
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                                parts: [{
                                        text: prompt
                                    }]
                            }]
                    })
                });
                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!generatedText) {
                    throw new Error('No response generated by Gemini');
                }
                return this.parseProgramResponse(generatedText);
            }
            catch (error) {
                console.error(`Error calling Gemini API for existing program enhancement (attempt ${attempt}/${maxRetries}):`, error);
                if (attempt === maxRetries) {
                    // On final attempt, try to create a basic fallback response
                    console.log(`Creating fallback response for existing program: ${program.name}`);
                    return {
                        name: program.name,
                        type: program.type || 'Balanced',
                        description: 'Fallback description',
                        duration: '4 weeks',
                        goals: ['Fallback goal'],
                        mealPlan: {
                            overview: 'Fallback meal plan',
                            dailyStructure: 'Fallback structure',
                            keyPrinciples: ['Fallback principle'],
                            sampleMeals: ['Fallback meal']
                        },
                        fitnessProgram: {
                            overview: 'Fallback fitness program',
                            workoutTypes: ['Fallback workout'],
                            frequency: '3 times per week',
                            duration: '30 minutes',
                            exercises: ['Fallback exercise']
                        },
                        guidelines: ['Fallback guideline'],
                        benefits: ['Fallback benefit'],
                        difficulty: 'Beginner',
                        tips: ['Fallback tip'],
                        notAllowed: ['snack'],
                        portionDetails: {
                            'fallback': {
                                palmPercentage: 'unknown',
                                spatulaSize: 'unknown',
                                examples: ['fallback'],
                                calories: '0'
                            }
                        }
                    };
                }
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            }
        }
        // This should never be reached, but just in case
        throw new Error('Failed to enhance existing program after all retries');
    }
    /**
     * Enhances a program with portion details and not-allowed foods using Gemini AI
     */
    async enhanceProgramPortionDetails(program) {
        const prompt = this.createProgramPortionDetailsPrompt(program);
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                                parts: [{
                                        text: prompt
                                    }]
                            }]
                    })
                });
                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!generatedText) {
                    throw new Error('No response generated by Gemini');
                }
                return this.parseProgramPortionDetailsResponse(generatedText);
            }
            catch (error) {
                console.error(`Error calling Gemini API for program portion details (attempt ${attempt}/${maxRetries}):`, error);
                if (attempt === maxRetries) {
                    // On final attempt, try to create a basic fallback response
                    console.log(`Creating fallback response for program: ${program.name}`);
                    return {
                        notAllowed: ['snack'], // Use valid option instead of 'fallback'
                        portionDetails: {
                            'fallback': {
                                palmPercentage: 'unknown',
                                spatulaSize: 'unknown',
                                examples: ['fallback'],
                                calories: '0'
                            }
                        }
                    };
                }
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            }
        }
        // This should never be reached, but just in case
        throw new Error('Failed to enhance program portion details after all retries');
    }
    /**
     * Creates comprehensive program details using Gemini AI
     */
    async createProgram(programType) {
        const prompt = this.createProgramPrompt(programType);
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                                parts: [{
                                        text: prompt
                                    }]
                            }]
                    })
                });
                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!generatedText) {
                    throw new Error('No response generated by Gemini');
                }
                return this.parseProgramResponse(generatedText);
            }
            catch (error) {
                console.error(`Error calling Gemini API for program creation (attempt ${attempt}/${maxRetries}):`, error);
                if (attempt === maxRetries) {
                    // On final attempt, try to create a basic fallback response
                    console.log(`Creating fallback response for program type: ${programType}`);
                    return {
                        name: `${programType} Program`,
                        type: programType,
                        description: `A comprehensive ${programType} program for health and wellness.`,
                        duration: '4 weeks',
                        goals: [`Achieve ${programType} goals`],
                        mealPlan: {
                            overview: `A structured meal plan for ${programType}`,
                            dailyStructure: '3 main meals + 2 snacks',
                            keyPrinciples: [`Focus on ${programType} principles`],
                            sampleMeals: ['Sample meal 1', 'Sample meal 2']
                        },
                        fitnessProgram: {
                            overview: `A fitness program designed for ${programType}`,
                            workoutTypes: ['Cardio', 'Strength training'],
                            frequency: '3 times per week',
                            duration: '30 minutes',
                            exercises: ['Exercise 1', 'Exercise 2']
                        },
                        guidelines: [`Follow ${programType} guidelines`],
                        benefits: [`Experience ${programType} benefits`],
                        difficulty: 'Beginner',
                        tips: [`Tip for ${programType} success`],
                        notAllowed: ['snack'],
                        portionDetails: {
                            'fallback': {
                                palmPercentage: 'unknown',
                                spatulaSize: 'unknown',
                                examples: ['fallback'],
                                calories: '0'
                            }
                        }
                    };
                }
                // Wait before retrying (exponential backoff)
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            }
        }
        // This should never be reached, but just in case
        throw new Error('Failed to create program after all retries');
    }
    /**
     * Creates a daily routine for an existing program using Gemini AI
     */
    async createProgramRoutine(program) {
        const prompt = this.createRoutinePrompt(program);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseRoutineResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for routine creation:', error);
            throw error;
        }
    }
    // Prompt creation methods (simplified versions)
    createVariationPrompt(meal, existingTitles) {
        return `Create a unique variation of this meal: ${meal.title}. Existing titles to avoid: ${existingTitles.join(', ')}. Return JSON with title, description, type, cookingTime, cookingMethod, ingredients, instructions, nutritionalInfo, categories, serveQty, and suggestions.`;
    }
    createCookingMethodPrompt(cookingMethod) {
        return `Enhance this cooking method: ${cookingMethod.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "howItWorks": "string",
  "equipment": ["string"],
  "bestFor": ["string"],
  "heatType": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createDietCategoryPrompt(category) {
        return `Enhance this diet category: ${category.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "kidsFriendly": boolean
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createEnhancementPrompt(meal) {
        return `Enhance this meal: ${meal.title}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "description": "string",
  "type": "string",
  "cookingTime": "string",
  "cookingMethod": "string",
  "ingredients": {},
  "instructions": ["string"],
  "nutritionalInfo": {},
  "categories": ["string"],
  "serveQty": "string",
  "suggestions": ["string"]
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createIngredientVariationPrompt(ingredient, existingTitles) {
        return `Create a unique variation of this ingredient: ${ingredient.title}. Existing titles to avoid: ${existingTitles.join(', ')}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "string", 
  "calories": number,
  "macros": {
    "protein": "string",
    "carbs": "string",
    "fat": "string"
  },
  "categories": ["string"],
  "features": {
    "fiber": "string",
    "g_i": "string",
    "season": "string",
    "water": "string",
    "rainbow": "string"
  },
  "techniques": ["string"],
  "storageOptions": {
    "countertop": "string",
    "fridge": "string",
    "freezer": "string"
  },
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createNewIngredientGenerationPrompt(type, existingTitles) {
        return `Generate a new unique ${type} ingredient. Existing titles to avoid: ${existingTitles.join(', ')}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "${type}", 
  "calories": number,
  "macros": {
    "protein": "string",
    "carbs": "string",
    "fat": "string"
  },
  "categories": ["string"],
  "features": {
    "fiber": "string",
    "g_i": "string",
    "season": "string",
    "water": "string",
    "rainbow": "string"
  },
  "techniques": ["string"],
  "storageOptions": {
    "countertop": "string",
    "fridge": "string",
    "freezer": "string"
  },
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createIngredientEnhancementPrompt(ingredient) {
        return `Enhance this ingredient: ${ingredient.title}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "title": "string",
  "type": "string", 
  "calories": number,
  "macros": {
    "protein": number,
    "carbs": number,
    "fat": number,
    "fiber": number
  },
  "categories": ["string"],
  "features": ["string"],
  "techniques": ["string"],
  "storageOptions": ["string"],
  "isAntiInflammatory": boolean,
  "alt": ["string"],
  "image": "string"
}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createExistingProgramEnhancementPrompt(program) {
        return `Enhance this existing program: ${program.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "name": "${program.name}",
  "type": "${program.type || 'Balanced'}",
  "description": "string",
  "duration": "string",
  "goals": ["string"],
  "mealPlan": {
    "overview": "string",
    "dailyStructure": "string",
    "keyPrinciples": ["string"],
    "sampleMeals": ["string"]
  },
  "fitnessProgram": {
    "overview": "string",
    "workoutTypes": ["string"],
    "frequency": "string",
    "duration": "string",
    "exercises": ["string"]
  },
  "guidelines": ["string"],
  "benefits": ["string"],
  "difficulty": "Beginner|Intermediate|Advanced",
  "tips": ["string"],
  "notAllowed": ["string"],
  "portionDetails": {
    "foodCategory": {
      "palmPercentage": "string",
      "spatulaSize": "string",
      "examples": ["string"],
      "calories": "string"
    }
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "notAllowed" array can ONLY contain these 4 options: "snack", "fruit", "dessert", "alcohol"
3. Choose the most appropriate option(s) based on the program's focus and goals.
4. The response should be valid JSON that can be parsed directly.
5. Keep the existing program name and type, but enhance all other fields.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createProgramPortionDetailsPrompt(program) {
        return `Enhance this program: ${program.name}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "notAllowed": ["string"],
  "portionDetails": {
    "foodCategory": {
      "palmPercentage": "string",
      "spatulaSize": "string",
      "examples": ["string"],
      "calories": "string"
    }
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "notAllowed" array can ONLY contain these 4 options: "snack", "fruit", "dessert", "alcohol"
3. Choose the most appropriate option(s) based on the program's focus and goals.
4. The response should be valid JSON that can be parsed directly.

Example structure for portionDetails:
- "protein": {"palmPercentage": "1 palm", "spatulaSize": "1 spatula", "examples": ["chicken", "fish"], "calories": "300"}
- "vegetables": {"palmPercentage": "2 palms", "spatulaSize": "2 spatulas", "examples": ["broccoli", "spinach"], "calories": "100"}
- "fruits": {"palmPercentage": "1 palm", "spatulaSize": "1 spatula", "examples": ["apple", "banana"], "calories": "80"}

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createProgramPrompt(programType) {
        return `Create a comprehensive program for type: ${programType}. 

Return a valid JSON object with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

{
  "name": "string",
  "description": "string",
  "duration": "string",
  "goals": ["string"],
  "mealPlan": "string",
  "fitnessProgram": "string",
  "guidelines": ["string"],
  "benefits": ["string"],
  "difficulty": "string",
  "tips": ["string"],
  "notAllowed": ["string"],
  "portionDetails": {
    "foodCategory": {
      "palmPercentage": "string",
      "spatulaSize": "string",
      "examples": ["string"],
      "calories": "string"
    }
  }
}

IMPORTANT RULES:
1. Return ONLY the JSON object. Do not include any code examples, explanations, or other text.
2. The "notAllowed" array can ONLY contain these 4 options: "snack", "fruit", "dessert", "alcohol"
3. Choose the most appropriate option(s) based on the program type and goals.
4. The response should be valid JSON that can be parsed directly.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    createRoutinePrompt(program) {
        return `Create a daily routine for program: ${program.name}. 

Return a valid JSON array with the following structure (ensure all property names are double-quoted and all string values are properly quoted):

[
  {
    "title": "string",
    "duration": "string",
    "description": "string"
  }
]

IMPORTANT: Return ONLY the JSON array. Do not include any code examples, explanations, or other text. The response should be valid JSON that can be parsed directly.

Ensure the JSON is properly formatted with double quotes around all property names and string values.`;
    }
    // Response parsing methods (simplified versions)
    parseVariationResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return {
                title: parsed.title || 'Untitled Variation',
                description: parsed.description,
                type: parsed.type,
                cookingTime: parsed.cookingTime,
                cookingMethod: parsed.cookingMethod,
                ingredients: parsed.ingredients || {},
                instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
                nutritionalInfo: parsed.nutritionalInfo,
                categories: Array.isArray(parsed.categories) ? parsed.categories : [],
                serveQty: parsed.serveQty,
                suggestions: parsed.suggestions
            };
        }
        catch (error) {
            console.error('Error parsing variation response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse variation response');
        }
    }
    parseCookingMethodResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return {
                description: parsed.description || 'No description available',
                howItWorks: parsed.howItWorks || 'No details available',
                equipment: Array.isArray(parsed.equipment) ? parsed.equipment : [],
                bestFor: Array.isArray(parsed.bestFor) ? parsed.bestFor : [],
                heatType: parsed.heatType || 'Unknown heat type'
            };
        }
        catch (error) {
            console.error('Error parsing cooking method response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse cooking method response');
        }
    }
    parseDietCategoryResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return {
                description: parsed.description || 'No description available',
                kidsFriendly: typeof parsed.kidsFriendly === 'boolean' ? parsed.kidsFriendly : false
            };
        }
        catch (error) {
            console.error('Error parsing diet category response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse diet category response');
        }
    }
    parseGeminiResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return {
                description: parsed.description,
                type: parsed.type,
                cookingTime: parsed.cookingTime,
                cookingMethod: parsed.cookingMethod,
                ingredients: parsed.ingredients || {},
                instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
                nutritionalInfo: parsed.nutritionalInfo,
                categories: Array.isArray(parsed.categories) ? parsed.categories : [],
                serveQty: parsed.serveQty,
                suggestions: parsed.suggestions
            };
        }
        catch (error) {
            console.error('Error parsing Gemini response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse Gemini response');
        }
    }
    parseIngredientResponse(response) {
        try {
            console.log('Raw Gemini response:', response.substring(0, 500) + '...');
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            console.log('Cleaned JSON:', cleanedResponse.substring(0, 500) + '...');
            const parsed = JSON.parse(cleanedResponse);
            return {
                title: parsed.title,
                type: parsed.type,
                calories: parsed.calories,
                macros: parsed.macros,
                categories: Array.isArray(parsed.categories) ? parsed.categories : undefined,
                features: parsed.features,
                techniques: Array.isArray(parsed.techniques) ? parsed.techniques : undefined,
                storageOptions: parsed.storageOptions,
                isAntiInflammatory: parsed.isAntiInflammatory,
                alt: Array.isArray(parsed.alt) ? parsed.alt : undefined,
                image: parsed.image
            };
        }
        catch (error) {
            console.error('Error parsing ingredient response:', error);
            console.error('Raw response:', response);
            // Try to extract the ingredient title from the response for fallback
            const titleMatch = response.match(/ingredient:\s*([^\n,]+)/i) ||
                response.match(/title["\s]*:\s*["']?([^"'\n,]+)/i) ||
                response.match(/enhance.*?:\s*([^\n,]+)/i);
            const ingredientTitle = titleMatch ? titleMatch[1].trim() : 'Unknown Ingredient';
            console.log(`Creating fallback response for ingredient: ${ingredientTitle}`);
            // Return a basic fallback response
            return {
                title: ingredientTitle,
                type: 'vegetable', // Default to vegetable as a safe fallback
                calories: 0,
                macros: { protein: '0', carbs: '0', fat: '0' },
                categories: ['fallback'],
                features: {
                    fiber: '0',
                    g_i: '0',
                    season: 'unknown',
                    water: '0',
                    rainbow: 'unknown'
                },
                techniques: ['fallback'],
                storageOptions: {
                    countertop: 'unknown',
                    fridge: 'unknown',
                    freezer: 'unknown'
                },
                isAntiInflammatory: false,
                alt: ['fallback'],
                image: ''
            };
        }
    }
    /**
     * Fixes common JSON formatting issues that AI models often produce
     */
    fixCommonJsonIssues(jsonString) {
        // Remove any leading/trailing text that's not JSON
        let cleaned = jsonString.trim();
        // Fix unquoted property names (more comprehensive)
        cleaned = cleaned.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
        // Fix single quotes to double quotes
        cleaned = cleaned.replace(/'/g, '"');
        // Fix trailing commas
        cleaned = cleaned.replace(/,(\s*[}\]])/g, '$1');
        // Fix boolean values that might be strings
        cleaned = cleaned.replace(/"true"/g, 'true');
        cleaned = cleaned.replace(/"false"/g, 'false');
        // Fix numeric values that might be strings
        cleaned = cleaned.replace(/"(\d+(?:\.\d+)?)"/g, '$1');
        // Fix escaped quotes within strings
        cleaned = cleaned.replace(/\\"/g, '"');
        // Fix newlines and tabs within strings
        cleaned = cleaned.replace(/\\n/g, ' ');
        cleaned = cleaned.replace(/\\t/g, ' ');
        // Fix multiple spaces
        cleaned = cleaned.replace(/\s+/g, ' ');
        // Fix missing closing braces/brackets
        const openBraces = (cleaned.match(/\{/g) || []).length;
        const closeBraces = (cleaned.match(/\}/g) || []).length;
        const openBrackets = (cleaned.match(/\[/g) || []).length;
        const closeBrackets = (cleaned.match(/\]/g) || []).length;
        // Add missing closing braces
        for (let i = 0; i < openBraces - closeBraces; i++) {
            cleaned += '}';
        }
        // Add missing closing brackets
        for (let i = 0; i < openBrackets - closeBrackets; i++) {
            cleaned += ']';
        }
        return cleaned;
    }
    parseProgramPortionDetailsResponse(response) {
        try {
            console.log('Raw program response:', response.substring(0, 500) + '...');
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // First, try to parse the JSON as-is to see if it's already valid
            try {
                const parsed = JSON.parse(cleanedResponse);
                console.log('JSON parsed successfully without cleaning');
                return {
                    notAllowed: Array.isArray(parsed.notAllowed) ? parsed.notAllowed : [],
                    portionDetails: parsed.portionDetails || {}
                };
            }
            catch (initialError) {
                console.log('Initial JSON parsing failed, attempting to fix...');
            }
            // If initial parsing failed, try to fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            console.log('Cleaned program JSON:', cleanedResponse.substring(0, 500) + '...');
            const parsed = JSON.parse(cleanedResponse);
            return {
                notAllowed: Array.isArray(parsed.notAllowed) ? parsed.notAllowed : [],
                portionDetails: parsed.portionDetails || {}
            };
        }
        catch (error) {
            console.error('Error parsing program portion details response:', error);
            console.error('Raw response:', response);
            // Try to extract program name from the response for fallback
            const programMatch = response.match(/program.*?:\s*["']?([^"'\n,]+)/i) ||
                response.match(/enhance.*?:\s*["']?([^"'\n,]+)/i);
            const programName = programMatch ? programMatch[1].trim() : 'Unknown Program';
            console.log(`Creating fallback response for program: ${programName}`);
            // Return a basic fallback response
            return {
                notAllowed: ['snack'], // Use valid option instead of 'fallback'
                portionDetails: {
                    'fallback': {
                        palmPercentage: 'unknown',
                        spatulaSize: 'unknown',
                        examples: ['fallback'],
                        calories: '0'
                    }
                }
            };
        }
    }
    parseProgramResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return parsed;
        }
        catch (error) {
            console.error('Error parsing program response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse program response');
        }
    }
    parseRoutineResponse(response) {
        try {
            // Clean the response more thoroughly
            let cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            // Try to extract JSON from the response if it's wrapped in other text
            const jsonMatch = cleanedResponse.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                cleanedResponse = jsonMatch[0];
            }
            // Fix common JSON issues
            cleanedResponse = this.fixCommonJsonIssues(cleanedResponse);
            const parsed = JSON.parse(cleanedResponse);
            return Array.isArray(parsed) ? parsed : [];
        }
        catch (error) {
            console.error('Error parsing routine response:', error);
            console.error('Raw response:', response);
            throw new Error('Failed to parse routine response');
        }
    }
}
exports.GeminiService = GeminiService;
