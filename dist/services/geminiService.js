"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeminiService = void 0;
class GeminiService {
    constructor() {
        this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';
        this.apiKey = process.env.VITE_GEMINI_API_KEY || '';
        if (!this.apiKey) {
            throw new Error('VITE_GEMINI_API_KEY environment variable is required');
        }
    }
    /**
     * Transforms a duplicate meal into a unique variation
     */
    async createMealVariation(originalMeal, existingTitles) {
        const prompt = this.createVariationPrompt(originalMeal, existingTitles);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseVariationResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for variation:', error);
            throw error;
        }
    }
    /**
     * Enhances cooking method details using Gemini AI
     */
    async enhanceCookingMethod(cookingMethod) {
        const prompt = this.createCookingMethodPrompt(cookingMethod);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseCookingMethodResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for cooking method:', error);
            throw error;
        }
    }
    /**
     * Enhances diet category details using Gemini AI
     */
    async enhanceDietCategory(category) {
        const prompt = this.createDietCategoryPrompt(category);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseDietCategoryResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for diet category:', error);
            throw error;
        }
    }
    /**
     * Enhances meal data using Gemini AI
     */
    async enhanceMealDetails(meal) {
        const prompt = this.createEnhancementPrompt(meal);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseGeminiResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API:', error);
            throw error;
        }
    }
    /**
     * Enhances ingredient with complete details using Gemini AI
     */
    async enhanceIngredientDetails(ingredient) {
        const prompt = this.createIngredientEnhancementPrompt(ingredient);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseIngredientResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for ingredient enhancement:', error);
            throw error;
        }
    }
    /**
     * Creates an ingredient variation using Gemini AI
     */
    async createIngredientVariation(originalIngredient, existingTitles) {
        const prompt = this.createIngredientVariationPrompt(originalIngredient, existingTitles);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseIngredientResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for ingredient variation:', error);
            throw error;
        }
    }
    /**
     * Generates a new unique ingredient of a specific type
     */
    async generateNewIngredient(type, existingTitles) {
        const prompt = this.createNewIngredientGenerationPrompt(type, existingTitles);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseIngredientResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for new ingredient generation:', error);
            throw error;
        }
    }
    /**
     * Enhances a program with portion details and not-allowed foods using Gemini AI
     */
    async enhanceProgramPortionDetails(program) {
        const prompt = this.createProgramPortionDetailsPrompt(program);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseProgramPortionDetailsResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for program portion details:', error);
            throw error;
        }
    }
    /**
     * Creates comprehensive program details using Gemini AI
     */
    async createProgram(programType) {
        const prompt = this.createProgramPrompt(programType);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseProgramResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for program creation:', error);
            throw error;
        }
    }
    /**
     * Creates a daily routine for an existing program using Gemini AI
     */
    async createProgramRoutine(program) {
        const prompt = this.createRoutinePrompt(program);
        try {
            const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                            parts: [{
                                    text: prompt
                                }]
                        }]
                })
            });
            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!generatedText) {
                throw new Error('No response generated by Gemini');
            }
            return this.parseRoutineResponse(generatedText);
        }
        catch (error) {
            console.error('Error calling Gemini API for routine creation:', error);
            throw error;
        }
    }
    // Prompt creation methods (simplified versions)
    createVariationPrompt(meal, existingTitles) {
        return `Create a unique variation of this meal: ${meal.title}. Existing titles to avoid: ${existingTitles.join(', ')}. Return JSON with title, description, type, cookingTime, cookingMethod, ingredients, instructions, nutritionalInfo, categories, serveQty, and suggestions.`;
    }
    createCookingMethodPrompt(cookingMethod) {
        return `Enhance this cooking method: ${cookingMethod.name}. Return JSON with description, howItWorks, equipment, bestFor, and heatType.`;
    }
    createDietCategoryPrompt(category) {
        return `Enhance this diet category: ${category.name}. Return JSON with description and kidsFriendly boolean.`;
    }
    createEnhancementPrompt(meal) {
        return `Enhance this meal: ${meal.title}. Return JSON with description, type, cookingTime, cookingMethod, ingredients, instructions, nutritionalInfo, categories, serveQty, and suggestions.`;
    }
    createIngredientVariationPrompt(ingredient, existingTitles) {
        return `Create a unique variation of this ingredient: ${ingredient.title}. Existing titles to avoid: ${existingTitles.join(', ')}. Return JSON with title, type, calories, macros, categories, features, techniques, storageOptions, isAntiInflammatory, alt, and image.`;
    }
    createNewIngredientGenerationPrompt(type, existingTitles) {
        return `Generate a new unique ${type} ingredient. Existing titles to avoid: ${existingTitles.join(', ')}. Return JSON with title, type, calories, macros, categories, features, techniques, storageOptions, isAntiInflammatory, alt, and image.`;
    }
    createIngredientEnhancementPrompt(ingredient) {
        return `Enhance this ingredient: ${ingredient.title}. Return JSON with title, type, calories, macros, categories, features, techniques, storageOptions, isAntiInflammatory, alt, and image.`;
    }
    createProgramPortionDetailsPrompt(program) {
        return `Enhance this program: ${program.name}. Return JSON with notAllowed array and portionDetails object.`;
    }
    createProgramPrompt(programType) {
        return `Create a comprehensive program for type: ${programType}. Return JSON with name, description, duration, goals, mealPlan, fitnessProgram, guidelines, benefits, difficulty, tips, notAllowed, and portionDetails.`;
    }
    createRoutinePrompt(program) {
        return `Create a daily routine for program: ${program.name}. Return JSON array with title, duration, and description for each routine item.`;
    }
    // Response parsing methods (simplified versions)
    parseVariationResponse(response) {
        try {
            const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            const parsed = JSON.parse(cleanedResponse);
            return {
                title: parsed.title || 'Untitled Variation',
                description: parsed.description,
                type: parsed.type,
                cookingTime: parsed.cookingTime,
                cookingMethod: parsed.cookingMethod,
                ingredients: parsed.ingredients || {},
                instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
                nutritionalInfo: parsed.nutritionalInfo,
                categories: Array.isArray(parsed.categories) ? parsed.categories : [],
                serveQty: parsed.serveQty,
                suggestions: parsed.suggestions
            };
        }
        catch (error) {
            console.error('Error parsing variation response:', error);
            throw new Error('Failed to parse variation response');
        }
    }
    parseCookingMethodResponse(response) {
        try {
            const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            const parsed = JSON.parse(cleanedResponse);
            return {
                description: parsed.description || 'No description available',
                howItWorks: parsed.howItWorks || 'No details available',
                equipment: Array.isArray(parsed.equipment) ? parsed.equipment : [],
                bestFor: Array.isArray(parsed.bestFor) ? parsed.bestFor : [],
                heatType: parsed.heatType || 'Unknown heat type'
            };
        }
        catch (error) {
            console.error('Error parsing cooking method response:', error);
            throw new Error('Failed to parse cooking method response');
        }
    }
    parseDietCategoryResponse(response) {
        try {
            const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            const parsed = JSON.parse(cleanedResponse);
            return {
                description: parsed.description || 'No description available',
                kidsFriendly: typeof parsed.kidsFriendly === 'boolean' ? parsed.kidsFriendly : false
            };
        }
        catch (error) {
            console.error('Error parsing diet category response:', error);
            throw new Error('Failed to parse diet category response');
        }
    }
    parseGeminiResponse(response) {
        try {
            const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            const parsed = JSON.parse(cleanedResponse);
            return {
                description: parsed.description,
                type: parsed.type,
                cookingTime: parsed.cookingTime,
                cookingMethod: parsed.cookingMethod,
                ingredients: parsed.ingredients || {},
                instructions: Array.isArray(parsed.instructions) ? parsed.instructions : [],
                nutritionalInfo: parsed.nutritionalInfo,
                categories: Array.isArray(parsed.categories) ? parsed.categories : [],
                serveQty: parsed.serveQty,
                suggestions: parsed.suggestions
            };
        }
        catch (error) {
            console.error('Error parsing Gemini response:', error);
            throw new Error('Failed to parse Gemini response');
        }
    }
    parseIngredientResponse(response) {
        try {
            const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            const parsed = JSON.parse(cleanedResponse);
            return {
                title: parsed.title,
                type: parsed.type,
                calories: parsed.calories,
                macros: parsed.macros,
                categories: Array.isArray(parsed.categories) ? parsed.categories : undefined,
                features: parsed.features,
                techniques: Array.isArray(parsed.techniques) ? parsed.techniques : undefined,
                storageOptions: parsed.storageOptions,
                isAntiInflammatory: parsed.isAntiInflammatory,
                alt: Array.isArray(parsed.alt) ? parsed.alt : undefined,
                image: parsed.image
            };
        }
        catch (error) {
            console.error('Error parsing ingredient response:', error);
            throw new Error('Failed to parse ingredient response');
        }
    }
    parseProgramPortionDetailsResponse(response) {
        try {
            const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            const parsed = JSON.parse(cleanedResponse);
            return {
                notAllowed: Array.isArray(parsed.notAllowed) ? parsed.notAllowed : [],
                portionDetails: parsed.portionDetails || {}
            };
        }
        catch (error) {
            console.error('Error parsing program portion details response:', error);
            throw new Error('Failed to parse program portion details response');
        }
    }
    parseProgramResponse(response) {
        try {
            const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            const parsed = JSON.parse(cleanedResponse);
            return parsed;
        }
        catch (error) {
            console.error('Error parsing program response:', error);
            throw new Error('Failed to parse program response');
        }
    }
    parseRoutineResponse(response) {
        try {
            const cleanedResponse = response.replace(/```json\n?|\n?```/g, '').trim();
            const parsed = JSON.parse(cleanedResponse);
            return Array.isArray(parsed) ? parsed : [];
        }
        catch (error) {
            console.error('Error parsing routine response:', error);
            throw new Error('Failed to parse routine response');
        }
    }
}
exports.GeminiService = GeminiService;
